<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=0.5, maximum-scale=3.0">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.5.0/math.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/objects/MarchingCubes.js"></script>

    
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/STLExporter.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/GLTFExporter.js"></script>
    
    <link href="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.css" rel="stylesheet"/>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">

    <style>
        :root {
            --color-primary: rgb(43, 72, 190);
            --color-secondary: rgb(28, 164, 107);
            --color-accent: rgb(218, 50, 106);
            --op: rgb(236, 72, 153);
            --var: rgb(52, 211, 153);
            --digit: rgb(167, 139, 250);
            --coeff: rgb(250, 204, 21);
            --br: rgb(251, 146, 60);
            --fn: rgb(59, 130, 246);
            --sup: rgb(250, 204, 21);
            --frac: rgb(34, 197, 94);
            
            --bg-main-start: #11151F;
            --bg-main-mid: #1f2937;
            --bg-main-end: #374151;
            --bg-panel: rgba(31, 41, 55, 0.6);
            --bg-sidebar: rgba(17, 24, 39, 0.75);
            --bg-input: rgba(255, 255, 255, 0.05);
            --bg-input-focus: rgba(255, 255, 255, 0.1);
            --bg-hover: rgba(255, 255, 255, 0.1);
            --bg-anim-controller: #262e3d;
            
            --bg-input-pos: rgba(59, 130, 246, 0.1);
            --bg-input-rot: rgba(167, 139, 250, 0.12);
            --bg-input-scale: rgba(52, 211, 153, 0.1);
            --bg-input-physics: rgba(251, 146, 60, 0.1);
            
            --border-color: rgba(255, 255, 255, 0.1);
            --border-subtle: rgba(255, 255, 255, 0.05);
            
            --text-light: #E6EDF3;
            --text-muted: #8B949E;
            --text-label: #cbd5e1;
            
            --shadow-glow: rgba(79, 142, 255, 0.25);
            
            --sidebar-width: 380px;
            --animation-tray-height: 220px;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            color: var(--text-light);
            background: linear-gradient(135deg, var(--bg-main-start), var(--bg-main-end));
            min-height: 100vh;
            line-height: 1.5;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .hidden { display: none !important; }

        .compact-input::placeholder {
            color: var(--text-muted);
            opacity: 0.8;
        }

        input[type="text"],
        input[type="number"],
        .field-input,
        .var-input {
            background: var(--bg-input) !important;
            border: 1px solid var(--border-color) !important;
            color: var(--text-light) !important;
            padding: 8px 10px !important;
            border-radius: 6px !important;
            transition: all 0.2s ease !important;
            width: 100% !important;
            font-size: 0.9rem !important;
        }

        input:focus {
            outline: none;
            border-color: var(--color-primary) !important;
            box-shadow: 0 0 0 2px var(--shadow-glow) !important;
            background: var(--bg-input-focus) !important;
            color: #94a3b8;
            padding: 4px 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            margin: 2px 0;
        }
        
        .timeline-container {
            height: 24px;
            position: relative;
            background: var(--bg-input);
            border-radius: 4px;
            overflow: hidden;
            margin: 0 8px 8px;
        }
        
        .timeline-progress {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background: var(--section-color, var(--color-primary));
            opacity: 0.7;
            transition: width 0.1s linear;
        }
        
        .timeline-handle {
            position: absolute;
            top: 50%;
            width: 12px;
            height: 12px;
            background: white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            cursor: pointer;
            box-shadow: 0 0 0 2px var(--section-color, var(--color-primary));
            z-index: 2;
        }
        
        .timeline-ticks {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 10px;
        }
        
        .tick {
            width: 1px;
            height: 6px;
            background: var(--border-color);
            margin-top: 2px;
        }
        
        .tick.major {
            height: 10px;
            background: var(--text-muted);
        }
        
        .compact-object-header {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 8px;
            align-items: center;
            padding: 4px 8px !important; 
            background-color: rgba(255,255,255,0.02);
        }

        .compact-object-header .object-name {
            font-size: 14px;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .compact-object-header .object-actions {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .playground-objects-container {
            space-y-4: 0;
        }
        .playground-object + .playground-object {
            margin-top: 0.75rem; 
        }
        .compact-object-header {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 8px;
            align-items: center;
            padding: 4px 10px !important; 
            background-color: rgba(255,255,255,0.02);
        }
        .compact-object-header .object-name {
            font-size: 14px;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .compact-object-header .object-actions {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .compact-object-header .tool-button {
            width: 28px !important; 
            height: 28px !important;
        }

        
        
        
        .v-mode-content {
            --section-color: #2563eb;  
            --section-bg: rgba(37, 99, 235, 0.25);
            --section-border: rgba(37, 99, 235, 0.5);
            --section-text: #bfdbfe;
            --section-highlight: rgba(37, 99, 235, 0.3);
            background: var(--section-bg);
            border: 2px solid var(--section-border);
            border-radius: 8px;
            margin: 8px 4px;
            padding: 4px;
        }
        
        
        .p-mode-content {
            --section-color: #7c3aed;  
            --section-bg: rgba(124, 58, 237, 0.25);
            --section-border: rgba(124, 58, 237, 0.5);
            --section-text: #ddd6fe;
            --section-highlight: rgba(124, 58, 237, 0.3);
            background: var(--section-bg);
            border: 2px solid var(--section-border);
            border-radius: 8px;
            margin: 8px 4px;
            padding: 4px;
        }
        
        
        .physics-mode-content {
            --section-color: #d97706;  
            --section-bg: rgba(217, 119, 6, 0.25);
            --section-border: rgba(217, 119, 6, 0.5);
            --section-text: #fde68a;
            --section-highlight: rgba(217, 119, 6, 0.3);
            background: var(--section-bg);
            border: 2px solid var(--section-border);
            border-radius: 8px;
            margin: 8px 4px;
            padding: 4px;
        }
        
        
        .var-section {
            --section-color: #10b981;  
            --section-bg: rgba(16, 185, 129, 0.1);
            --section-border: rgba(16, 185, 129, 0.3);
            --section-text: #6ee7b7;
            --section-highlight: rgba(16, 185, 129, 0.2);
            
            background: var(--section-bg);
            border-left: 3px solid var(--section-color);
            margin: 8px 6px;
            border-radius: 0 6px 6px 0;
            overflow: hidden;
        }

        
        .section-title, .var-section .section-title {
            background: var(--section-highlight);
            color: white;
            padding: 8px 12px;
            font-size: 0.8rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 8px;
            margin: -4px -4px 8px -4px;
            border-bottom: 2px solid var(--section-border);
            border-radius: 6px 6px 0 0;
            text-shadow: 0 1px 1px rgba(0,0,0,0.3);
        }
        
        
        .field-group {
            background: var(--section-bg);
            border: 1px solid var(--section-border);
            border-radius: 6px;
            margin: 8px 6px;
            overflow: hidden;
        }
        
        
        .field-input, 
        .v-mode-content input[type="text"], 
        .v-mode-content input[type="number"],
        .p-mode-content input[type="text"],
        .p-mode-content input[type="number"],
        .physics-mode-content input[type="text"],
        .physics-mode-content input[type="number"] {
            background: rgba(0, 0, 0, 0.3) !important;
            border: 1px solid var(--section-border) !important;
            color: white !important;
            padding: 8px 10px !important;
            border-radius: 6px !important;
            transition: all 0.2s ease !important;
            width: 100% !important;
            box-sizing: border-box !important;
            font-size: 0.9rem !important;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.2);
        }
        
        .field-input:focus {
            outline: none !important;
            border-color: var(--section-color) !important;
            box-shadow: 0 0 0 2px var(--section-highlight) !important;
            background: rgba(255, 255, 255, 0.1) !important;
        }
        
        
        .field-label {
            color: var(--section-text);
            font-size: 0.7rem;
            font-weight: 500;
            margin-bottom: 4px;
            display: block;
        }
        
        
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 36px;
            height: 20px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.1);
            transition: .4s;
            border-radius: 20px;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .toggle-slider {
            background-color: var(--section-color);
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(16px);
        }


        .var-input-container {
            padding: 8px 12px 10px;
        }


        .var-input {
            background: rgba(16, 185, 129, 0.08) !important;
            border: 1px solid rgba(16, 185, 129, 0.2) !important;
            color: #a7f3d0 !important;
        }

        .var-input:focus {
            border-color: #10b981 !important;
            box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.2) !important;
            background: rgba(16, 185, 129, 0.15) !important;
        }

        
        .var-label {
            color: #6ee7b7;
            font-size: 0.7rem;
            font-weight: 500;
            margin-bottom: 4px;
            display: block;
        }

        
        .var-toggle {
            accent-color: #10b981;
        }

        
        .var-toggle-container {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 6px;
        }

        
        
        
        .p-mode-table-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            padding: 8px 12px;
        }
        
        .p-mode-table-grid input[type="text"] {
            width: 100%;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid var(--border-subtle);
            color: var(--text-light);
            padding: 6px 8px;
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            transition: all 0.2s ease;
        }

        .p-mode-table-grid input[type="text"]:focus {
            outline: none;
            border-color: var(--color-primary);
            box-shadow: 0 0 0 2px var(--shadow-glow);
            background: var(--bg-input-focus);
        }
        
        .p-mode-table-grid .field-label {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-bottom: 2px;
        }

        
        
        .animation-tray-wrapper.hidden {
            transform: translateY(100%);
        }
        
        
        #global-animation-tray {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        
        .anim-tray-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: var(--bg-anim-controller);
            border-bottom: 1px solid var(--border-subtle);
        }
        
        .anim-tray-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-light);
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        
        .anim-tray-mode-toggle {
            display: inline-flex;
            background: var(--bg-input);
            border-radius: 6px;
            padding: 2px;
            gap: 2px;
        }
        
        .anim-tray-mode-toggle input[type="radio"] {
            position: absolute;
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .anim-tray-mode-toggle label {
            padding: 4px 8px;
            font-size: 0.7rem;
            font-weight: 500;
            color: var(--text-muted);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .anim-tray-mode-toggle input:checked + label {
            background: var(--section-color, var(--color-primary));
            color: white;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }
        
        
        #animation-cards-container {
            flex: 1;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 8px;
            overflow-y: auto;
            background: yellow;
        }
        
        
        .tray-controls {
            position: absolute;
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            z-index: 30;
        }
        
        .tray-control-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-hover);
            border: 1px solid var(--border-subtle);
            color: var(--text-light);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .tray-control-btn:hover {
            background: var(--color-primary);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }


        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { 
           -webkit-appearance: none; 
           margin: 0; 
        }

        input[type=number] {
           -moz-appearance: textfield; 
        }
        :root {
            --color-primary:rgb(43, 72, 190); 
            --color-secondary:rgb(28, 164, 107); 
            --color-accent:rgb(218, 50, 106); 
            --bg-main-start: #11151F; 

            --bg-main-mid: #1f2937;
            --bg-main-end: #374151;
            --bg-panel: rgba(31, 41, 55, 0.6);
            --bg-sidebar: rgba(17, 24, 39, 0.75);
            --bg-input: rgba(255, 255, 255, 0.05);
            --bg-input-focus: rgba(255, 255, 255, 0.1);
            --bg-hover: rgba(255, 255, 255, 0.1);
            --border-color: rgba(255, 255, 255, 0.1);
            --border-subtle: rgba(255, 255, 255, 0.05);
            --shadow-glow: rgba(79, 142, 255, 0.25);

            
            --text-light: #E6EDF3;
            --text-muted: #8B949E;
            --text-label: #cbd5e1;
            
            --op:rgb(236, 72, 153);
            --var:rgb(52, 211, 153);
            --digit:rgb(167, 139, 250);
            --coeff:rgb(250, 204, 21);
            --br:rgb(251, 146, 60);
            --fn:rgb(59, 130, 246);
            --sup:rgb(250, 204, 21);
            --frac:rgb(34, 197, 94);
            --sidebar-width: 380px;
            --animation-tray-height: 220px;
            
            --bg-input-pos: rgba(59, 130, 246, 0.1);     
            --bg-input-rot: rgba(167, 139, 250, 0.12);   
            --bg-input-scale: rgba(52, 211, 153, 0.1);   
            --bg-input-physics: rgba(251, 146, 60, 0.1); 
            --bg-anim-controller: #262e3d;               
        }

        body.light-theme {
            
            --color-primary: #5a7d9a;   
            --color-secondary: #6a8a65; 
            --color-accent: #c4765a;    
        
            
            --bg-main-start: #f8f5f1;
            --bg-main-mid: #f3efeb;
            --bg-main-end: #ede7e1;
            --bg-panel: rgba(230, 225, 218, 0.85);
            --bg-sidebar: rgba(240, 236, 232, 0.9);
            
            
            --bg-input: rgba(78, 68, 58, 0.05);
            --bg-input-focus: rgba(78, 68, 58, 0.1);
            --bg-hover: rgba(78, 68, 58, 0.08);
            --border-color: rgba(78, 68, 58, 0.15);
            --border-subtle: rgba(78, 68, 58, 0.1);
        
            
            --text-light: #4E443A;      
            --text-muted: #8A7F72;       
            --text-label: #6B6054;       
            
            
            --shadow-glow: rgba(90, 125, 154, 0.2);
            --canvas-bg: #EAE4DC;
        }

        body { font-family: 'Inter', sans-serif; background: var(--bg-main-start); color: var(--text-light); overflow: hidden; }
        .font-mono { font-family: 'JetBrains Mono', monospace; }
        .backdrop-blur-lg { backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px); }
        
        .view-controls {
            background : var(--bg-panel);
        }

        .animation-tray-wrapper {
            grid-area: right-panel;
            width: 252px;
            display: flex;
            flex-direction: column;
            height: auto; 
            max-height: 100%; 
            background: var(--bg-panel);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-left: 1px solid var(--border-color);
            overflow-y: auto; 
            position: relative; 
        }
        #add-object-menu {
            background-color:rgb(65, 142, 163); 
            font-family: 'Segoe UI', sans-serif; 
            font-size: 14px;                     
            font-weight: 500;                    
            color: dark blue;  
        }

        
        
        



        .top-bar { grid-area: header; background: var(--bg-panel); border-bottom: 1px solid var(--border-color); z-index: 15; }
        .left-panel { grid-area: left-panel; background: var(--bg-sidebar); border-right: 1px solid var(--border-color); display: flex; flex-direction: column; position: relative; overflow: hidden; transition: padding 0.3s ease; }
        .sidebar-content { flex-grow: 1; overflow-y: auto; }
        .main-viewport {
            grid-area: main-view;
            position: relative;
            background-image: radial-gradient(var(--border-subtle) 1px, transparent 1px);
            background-size: 20px 20px;
        }
        #plot-container { cursor: grab; }
        #plot-container:active { cursor: grabbing; }
        .right-toolbar { grid-area: right-toolbar; background: var(--bg-panel); border-left: 1px solid var(--border-color); }

        #resize-handle { position: absolute; top: 0; right: -3px; bottom: 0; width: 6px; cursor: col-resize; z-index: 100; transition: background-color 0.2s; }
        #resize-handle:hover, body.is-resizing #resize-handle { background-color: rgba(59, 130, 246, 0.5); }
        body.is-resizing { cursor: col-resize !important; user-select: none; }
        




        .app-grid {
            display: grid;
            grid-template-areas: "header header header" "left-panel main-view right-panel";
            grid-template-rows: 60px minmax(0, 1fr);
            grid-template-columns: var(--sidebar-width) 1fr 252px; 
            height: 100vh;
            width: 100vw;
        }
        #global-animation-tray {
            width: 252px;
            height: 100%;
            display: flex;
            flex-direction: column;
            gap: 10px;
        
            
            padding: 10px;
        
            
            overflow-y: auto;
            min-height: 0; 
        }
        
        
        #animation-cards-container {
            display: flex;
            flex-direction: column;
            flex-wrap: nowrap;
            gap: 10px;
            background: var(--bg-panel);
        }
        
        
        #tray-resize-handle {
            display: none;
        }
       
        #tray-resize-handle:hover, body.is-tray-resizing #tray-resize-handle { background-color: rgba(59, 130, 246, 0.5); }
        body.is-tray-resizing { cursor: row-resize !important; user-select: none; }

        .status-bar { position: absolute; bottom: 0; left: 0; right: 0; height: 24px; pointer-events: none; }
        .status-item { font-size: 12px; color: var(--text-muted); }

        .sidebar-content::-webkit-scrollbar, .waypoints-container::-webkit-scrollbar { width: 6px; }
        .sidebar-content::-webkit-scrollbar-track, .waypoints-container::-webkit-scrollbar-track { background: transparent; }
        .sidebar-content::-webkit-scrollbar-thumb, .waypoints-container::-webkit-scrollbar-thumb { background: var(--color-primary); border-radius: 3px; }
        .sidebar-content::-webkit-scrollbar-thumb:hover, .waypoints-container::-webkit-scrollbar-thumb:hover { background: var(--color-secondary); }

        .logo { font-size: 24px; font-weight: 800; background: linear-gradient(45deg, var(--color-primary), var(--color-secondary)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .mode-tabs { display: flex; justify-content: flex-end; background: var(--bg-input); border-radius: 12px; padding: 5px; border: 1px solid var(--border-subtle); }
        .mode-tab { flex: 1; padding: 8px 12px; text-align: center; border-radius: 9px; cursor: pointer; transition: all 0.3s ease; font-size: 13px; font-weight: 600; color: var(--text-muted); }
        .mode-tab.active { background: linear-gradient(45deg, var(--color-primary), var(--color-secondary)); box-shadow: 0 0 20px var(--shadow-glow); color: white; }
        .mode-tab:not(.active):hover { background: var(--bg-hover); color: var(--text-light); }
        .accordion-header { font-size: 1rem; font-weight: 600; color: var(--text-light); cursor: pointer; display: flex; justify-content: space-between; align-items: center; padding: 12px 8px; border-radius: 8px; transition: background-color 0.2s ease; }
        .accordion-header:hover { background-color: var(--bg-hover); }
        .accordion-header.open { background-color: var(--bg-input); }
        .accordion-header .chevron-container { width: 24px; height: 24px; background-color: var(--bg-input); border-radius: 50%; display: flex; align-items: center; justify-content: center; transition: transform 0.3s ease-in-out; }
        .accordion-header.open .chevron-container { transform: rotate(180deg); }
        .accordion-content { max-height: 0; 
            overflow: hidden; 
            transition: max-height 0.4s ease-in-out, padding-bottom 0.4s ease-in-out; 
            transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
            padding-bottom: 0;
        }

        .btn:active, .tool-button:active {
            transform: translateY(1px) scale(0.98);
            box-shadow: 0 1px 5px rgba(0,0,0,0.2);
            transition: transform 0.1s ease, box-shadow 0.1s ease;
        }
        .accordion-content.open { padding-bottom: 5px; }
        label { color: var(--text-label); font-size: 0.875rem; font-weight: 500; display: block; margin-bottom: 6px; }
        .form-input, .form-select { background: var(--bg-input); border: 1px solid var(--border-color); border-radius: 0.5rem; color: var(--text-light); transition: all 0.3s ease; padding: 10px 12px; font-size: 0.875rem; }
        .form-input:focus, .form-select:focus { outline: none; border-color: var(--color-primary); box-shadow: 0 0 0 3px rgba(79, 142, 255, 0.3); background: var(--bg-input-focus); }
        
        .form-input.anim-controlled {
            background: repeating-linear-gradient(45deg, var(--bg-input), var(--bg-input) 10px, var(--bg-input-focus) 10px, var(--bg-input-focus) 20px);
            animation: anim-controlled-march 2s linear infinite;
            pointer-events: none;
            color: var(--text-muted);
        }
        @keyframes anim-controlled-march { from { background-position: 0 0; } to { background-position: 40px 0; } }

        .math-input-container { background: var(--bg-input); border: 1px solid var(--border-color); border-radius: 8px; transition: all 0.3s ease; padding: 8px 12px; font-size: 16px; }
        .math-input-container.mq-focused { outline: none; border-color: var(--color-primary); box-shadow: 0 0 0 3px var(--shadow-glow); background: var(--bg-input-focus); }
        .btn { padding: 10px 14px; border: none; border-radius: 0.5rem; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.2s ease; text-transform: uppercase; letter-spacing: 0.5px; display: flex; align-items: center; justify-content: center; gap: 8px; user-select: none; }
        .btn-primary { background: linear-gradient(45deg, var(--color-primary), var(--color-secondary)); color: white; }
        .btn-secondary { background: var(--bg-hover); color: var(--text-light); border: 1px solid var(--border-subtle); }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 8px 25px var(--shadow-glow); }
        .btn:active { transform: translateY(0px); box-shadow: 0 4px 15px var(--shadow-glow); }
        .btn.active-perf { background: var(--color-primary); }
        .colormap-btn { height: 30px; border-radius: 6px; border: 2px solid transparent; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: 600; color: white; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); }
        .colormap-btn:hover { transform: scale(1.05); }
        .colormap-btn.active { border-color: var(--color-secondary); box-shadow: 0 0 0 2px var(--color-secondary); }
        
        .hidden { display: none !important; }

        .toast { position: fixed; top: 80px; left: 50%; transform: translateX(-50%); background-color: var(--color-secondary); color: white; padding: 12px 24px; border-radius: 8px; z-index: 1050; opacity: 0; transition: opacity 0.3s, top 0.3s; pointer-events: none; }
        .toast.show { opacity: 1; top: 90px; }

        .right-toolbar { display: flex; flex-direction: column; align-items: center; padding: 16px 0; gap: 16px; }
        .tool-group { display: flex; flex-direction: column; align-items: center; gap: 12px; }
        .tool-group .separator { width: 60%; height: 1px; background-color: var(--border-color); margin: 4px 0; }
        .tool-button { width: 48px; height: 48px; border-radius: 14px; color: var(--text-muted); display: flex; align-items: center; justify-content: center; transition: all 0.2s ease; border: 1px solid transparent; background: transparent; }
        .tool-button:hover { color: var(--text-light); background-color: var(--bg-hover); }
        .tool-button.active { color: white; background: var(--color-primary); box-shadow: 0 4px 15px var(--shadow-glow); }

        .math-input-group { margin-bottom: 8px; position: relative; }
        .math-input-actions { position: absolute; top: 4px; right: 4px; display: flex; gap: 4px; }
        .math-input-action-btn { background: var(--bg-input-focus); border: none; color: var(--text-muted); border-radius: 6px; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; }
        .math-input-action-btn:hover { background: var(--bg-hover); color: var(--text-light); }

        .calculator-pad { display: grid; grid-template-columns: repeat(7, 1fr); gap: 6px; margin-top: 12px; border-top: 1px solid var(--border-subtle); padding-top: 12px; }
        .calc-key { padding: 6px 4px; font-size: 14px; font-weight: 600; border-radius: 8px; background-color: var(--bg-input); color: var(--text-label); border: 1px solid transparent; transition: all 0.2s ease; text-align: center; }
        .calc-key:hover { background-color: var(--bg-hover); border-color: var(--color-primary); color: var(--text-light); transform: translateY(-1px); }
        .calc-key:active { transform: translateY(0); background-color: var(--bg-input-focus); }
        .calc-key.op-key { color: var(--op); font-size: 16px; }
        .calc-key.clear-key { background-color: var(--color-accent); color: white; }
        
        .anim-tray-controller { background: rgba(30, 33, 50, 0.5); border: 1px solid var(--border-subtle); border-left: 3px solid var(--component-accent, var(--color-primary)); border-radius: 8px; padding: 8px; display: flex; flex-direction: column; gap: 8px; flex: 0 0 280px; }
        .anim-tray-header { display: grid; grid-template-columns: 1fr auto; align-items: center; gap: 4px; }
        .anim-tray-header h3 { margin: 0; font-size: 0.8rem; font-weight: 600; color: var(--text-light); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .anim-tray-header h3 .accent-dot { color: var(--component-accent, var(--color-primary)); font-size: 1.1em; }
        .anim-tray-mode-toggle { display: flex; background-color: var(--bg-input); border-radius: 6px; padding: 2px; }
        .anim-tray-mode-toggle label { padding: 1px 6px; font-size: 0.6rem; font-weight: 700; text-transform: uppercase; color: var(--text-muted); cursor: pointer; border-radius: 4px; transition: all 0.2s ease;}
        .anim-tray-mode-toggle input:checked + label { background-color: var(--component-accent, var(--color-secondary)); color: white; box-shadow: 0 0 8px -2px var(--component-accent, var(--color-secondary)); }
        .anim-tray-mode-toggle input { display: none; }
        .anim-tray-player { display: flex; align-items: center; gap: 5px; background-color: var(--bg-input); padding: 3px; border-radius: 6px; }
        .anim-tray-player .icon-btn { color: var(--text-muted); font-size: 0.75rem; width: 22px; height: 22px; border-radius: 50%; display: flex; align-items: center; justify-content: center; }
        .anim-tray-player .icon-btn:hover { background-color: var(--bg-hover); color: var(--text-light); }
        .anim-tray-player .icon-btn.active { color: var(--component-accent, var(--color-primary)); }
        .anim-tray-player input[type="range"] { flex-grow: 1; height: 4px; background: var(--bg-input); -webkit-appearance: none; appearance: none; border-radius: 2px; outline: none; transition: opacity .2s; }
        .anim-tray-player input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 12px; height: 12px; background: var(--component-accent, var(--color-primary)); border-radius: 50%; cursor: pointer; }
        .anim-tray-player .slider-value { background-color: var(--bg-input-focus); padding: 1px 5px; font-size: 0.65rem; min-width: 38px; text-align: center; border-radius: 4px; font-family: 'JetBrains Mono', monospace; }
        .anim-tray-fieldset { border: 1px solid var(--border-subtle); border-radius: 6px; padding: 6px; margin: 0; }
        .anim-tray-fieldset legend { font-size: 0.65rem; font-weight: 600; text-transform: uppercase; color: var(--text-muted); padding: 0 5px; }
        .anim-tray-fieldset .legend-checkbox { display: flex; align-items: center; gap: 4px; font-size: 0.65rem; font-weight: 600; text-transform: uppercase; color: var(--text-muted); }
        .compact-input-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 4px; }
        .compact-input-label { display: flex; flex-direction: column; font-size: 0.6rem; color: var(--text-muted); gap: 1px; }
        .compact-input, .compact-select { width: 100%; background-color: var(--bg-input-focus); border: 1px solid var(--border-subtle); color: var(--text-light); border-radius: 4px; padding: 3px 5px; font-size: 0.7rem; font-family: 'JetBrains Mono', monospace; outline: none; -moz-appearance: textfield; }
        .compact-input::-webkit-outer-spin-button, .compact-input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        .compact-input:focus, .compact-input:hover, .compact-select:focus, .compact-select:hover { border-color: var(--component-accent, var(--color-primary)); }
        .compact-select { -webkit-appearance: none; appearance: none; background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%239ca3af' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e"); background-position: right 0.5rem center; background-repeat: no-repeat; background-size: 1.5em 1.5em; padding-right: 2.5rem; }
        .anim-tray-p-mode-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 4px; }
        .anim-tray-p-mode-field { display: flex; align-items: center; gap: 4px; }
        .anim-tray-p-mode-field .compact-input { flex-grow: 1; }
        .p-mode-live-value { font-size: 0.7rem; font-family: 'JetBrains Mono', monospace; color: var(--text-muted); background: var(--bg-input); padding: 3px 5px; border-radius: 4px; text-align: right; min-width: 40px; }
        .compact-input.input-error { border-color: var(--color-error) !important; box-shadow: 0 0 0 2px var(--color-error) !important; }
        .waypoints-container { max-height: 80px; overflow-y: auto; padding-right: 5px; }
        .waypoint-item { display: grid; grid-template-columns: 1fr 1fr 1fr auto; gap: 4px; align-items: center; margin-bottom: 4px; }
        .waypoint-item .compact-input { padding: 2px 4px; font-size: 0.65rem; }
        .waypoint-remove-btn { width: 20px; height: 20px; font-size: 0.6rem; }

        .mq-editable-field .mq-root-block { overflow-x: auto; white-space: nowrap; scrollbar-width: thin; scrollbar-color: var(--color-primary) transparent; }
        .mq-editable-field .mq-root-block::-webkit-scrollbar { height: 4px; }
        .mq-editable-field .mq-root-block::-webkit-scrollbar-track { background: transparent; }
        .mq-editable-field .mq-root-block::-webkit-scrollbar-thumb { background-color: var(--color-primary); border-radius: 2px; }
        .mq-editable-field .mq-cursor { border-left: 2px solid hsl(0, 100.00%, 50.00%) !important; }

        
        .math-input-group {
            position: relative;
        }

        .math-input-container {
            display: flex;
            align-items: center;
        }

        .math-input-container .mq-editable-field {
            flex-grow: 1;
        }

        .calc-trigger-btn {
            background: var(--bg-input-focus);
            border: 1px solid var(--border-color);
            color: var(--text-muted);
            border-radius: 6px;
            width: 34px;
            height: 34px;
            margin-left: 8px;
            cursor: pointer;
            transition: all 0.2s;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .calc-trigger-btn:hover {
            background: var(--bg-hover);
            color: var(--text-light);
            border-color: var(--color-primary);
        }

        #calculator-keypad button {
            background-color: var(--bg-input);
            color: var(--text-label);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            padding: 8px 4px;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        #calculator-keypad button:hover {
            background-color: var(--bg-hover);
            border-color: var(--color-primary);
            transform: translateY(-1px);
        }

        #calculator-keypad button.op-key {
            color: var(--op);
            font-size: 16px;
        }

        #calculator-keypad button.fn-key {
            color: var(--fn);
        }
        
        #calculator-display-mq {
            display: block;
            width: 100%;
            font-size: 18px;
            padding: 4px 8px;
            min-height: 36px;
            color: white;
        }
        
        .playground-objects-container {
            space-y-4: 0; 
        }
        .playground-object + .playground-object {
            margin-top: 0.75rem; 
        }
        .playground-object-header {
            padding: 6px 10px !important; 
        }
        .playground-object-header .tool-button {
            width: 28px !important; 
            height: 28px !important;
        }

        
        #calculator-display-mq .mq-root-block {
            white-space: normal;
        }
        span.mq-binary-operator, span.mq-unary-operator, span.mq-operator-name, .mq-rel { color: var(--op) !important; font-weight: bold !important; }
        span.mq-variable, .mq-letter { color: var(--var) !important; font-style: italic !important; font-weight: bold !important; }
        span.mq-digit, span.mq-number { color: var(--digit) !important; font-weight: bold !important; }
        .highlight-coeff { color: var(--coeff) !important; font-weight: bold !important; }
        span.mq-paren, span.mq-bracket { color: var(--br) !important; font-weight: bold !important; }
        span.mq-function-name, .mq-sqrt-prefix, .mq-sqrt-stem { color: var(--fn) !important; font-weight: bold !important; }
        .mq-sup, .mq-sub { color: var(--sup) !important; font-style: italic !important; font-weight: bold !important; }
        span.mq-fraction .mq-numerator, span.mq-fraction .mq-denominator { color: var(--frac) !important; }

        .playground-object { border: 1px solid var(--border-color); border-radius: 12px; background: var(--bg-input); transition: border-color 0.3s, box-shadow 0.3s; }
        .playground-object.focused { border-color: var(--color-secondary); box-shadow: 0 0 15px rgba(34, 197, 94, 0.3); }
        .playground-object-header { background: rgba(255,255,255,0.03); padding: 8px 12px; border-bottom: 1px solid var(--border-color); }
        .dropdown-menu { position: absolute; z-index: 10; background-color: var(--bg-panel); border: 1px solid var(--border-color); border-radius: 8px; padding: 8px; box-shadow: 0 10px 25px rgba(0,0,0,0.3); display: none; }
        .dropdown-menu.show { display: block; }
        .dropdown-item { padding: 8px 12px; border-radius: 6px; cursor: pointer; transition: background-color 0.2s; }
        .dropdown-item:hover { background-color: var(--bg-hover); }

        .preset-card:hover { transform: translateY(-2px); background-color: var(--bg-hover); }

        .fullscreen-mode .main-viewport {
            display: block;
        }
        
        .fullscreen-mode .app-grid {
            grid-template-columns: 1fr;
            grid-template-rows: 1fr;
        }

        .exit-mode-btn { position: absolute; top: 20px; right: 20px; z-index: 100; display: none; background: var(--bg-panel); color: var(--text-light); padding: 8px 12px; border-radius: 10px; border: 1px solid var(--border-color); cursor: pointer; font-size: 14px; font-weight: 600; align-items: center; gap: 8px; backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); }
        .exit-mode-btn:hover { background: var(--bg-hover); border-color: var(--color-primary); }
        .zen-mode #exit-zen-mode, .fullscreen-zen-mode #exit-fullscreen-mode { display: flex; }
        
        #global-animation-tray {
            
            background: var(--bg-panel); 
            backdrop-filter: blur(20px); 
            border-top: 1px solid rgba(255, 255, 255, 0.15); 
        }

        
        

        
        .anim-tray-controller {
            flex: 1 0 10% !important; 
            gap: 3px !important;
            padding: 4px !important;
        }

        
        .anim-tray-header {
            display: grid;
            grid-template-columns: 1fr auto; 
            align-items: center;
            gap: 4px;
            margin-bottom: 2px;
        }
        .anim-tray-header h3 {
            font-size: 0.7rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis; 
            margin: 0;
        }
        .anim-tray-mode-toggle {
            background-color: rgba(0,0,0,0.15); 
            border-radius: 5px;
            padding: 1px;
            display: flex;
        }
        .anim-tray-mode-toggle label {
            padding: 0px 5px;
            font-size: 0.6rem;
            border-radius: 4px;
        }
        .anim-tray-mode-toggle input:checked + label {
            box-shadow: none; 
        }


        
        .anim-tray-player {
            gap: 2px;
            padding: 2px;
        }
        .anim-tray-player input[type="range"] {
            flex-grow: 0 !important;
            width: 70px; 
        }
        .anim-tray-player .icon-btn {
            width: 18px;
            height: 18px;
        }
        .anim-tray-player .slider-value {
            min-width: 28px;
            padding: 0px 3px;
            font-size: 0.6rem;
        }

        
        .v-mode-content, .p-mode-content, .physics-mode-content {
            gap: 3px !important;
        }
        .anim-tray-fieldset {
            padding: 3px 5px;
        }
        .anim-tray-fieldset legend {
            font-size: 0.6rem;
            padding: 0 2px;
        }

        
        .compact-input, .compact-select {
            padding: 1px 3px;
            font-size: 0.65rem;
            height: 19px;
            color : green:
        }
        .compact-input-grid {
            gap: 2px;
        }
        .p-mode-row-label, .legend-checkbox {
            font-size: 0.65rem;
            margin-bottom: 2px;
        }

        
        .waypoints-container {
            max-height: 42px;
        }
        .waypoint-item {
            gap: 2px;
            margin-bottom: 2px;
        }
        .waypoint-remove-btn, .add-waypoint-btn {
            height: 18px;
        }
        .add-waypoint-btn {
            margin-top: 2px !important;
        }
        .slicing-axis-toggle label {
            color: var(--text-muted);
            transition: all 0.2s ease;
        }
        .slicing-axis-toggle input:checked + label {
            background-color: var(--color-primary);
            color: white;
            box-shadow: 0 0 8px -2px var(--color-primary);
        }
        

        
        .anim-tray-controller {
            
            flex-shrink: 0; 
            gap: 3px !important;
            padding: 4px !important;
            background: rgba(30, 33, 50, 0.7);
            backdrop-filter: blur(8px);
            border-radius: 8px; 
            border: 1px solid var(--border-subtle); 
        }

        
        .anim-tray-header {
            display: grid;
            grid-template-columns: 1fr auto; 
            align-items: center;
            gap: 4px;
            margin-bottom: 2px;
        }
        .anim-tray-header h3 {
            font-size: 0.7rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis; 
            margin: 0;
        }
        .anim-tray-mode-toggle {
            background-color: rgba(0,0,0,0.15); 
            border-radius: 5px;
            padding: 1px;
            display: flex;
        }
        .anim-tray-mode-toggle label {
            padding: 0px 5px;
            font-size: 0.6rem;
            border-radius: 4px;
        }
        .anim-tray-mode-toggle input:checked + label {
            box-shadow: none; 
        }


        
        .anim-tray-player {
            gap: 2px;
            padding: 2px;
        }
        .anim-tray-player input[type="range"] {
            flex-grow: 0 !important; 
            width: 70px; 
        }
        .anim-tray-player .icon-btn {
            width: 18px;
            height: 18px;
        }
        .anim-tray-player .slider-value {
            min-width: 28px;
            padding: 0px 3px;
            font-size: 0.6rem;
        }

        
        .v-mode-content, .p-mode-content, .physics-mode-content {
            gap: 3px !important;
        }
        .anim-tray-fieldset {
            padding: 3px 5px;
        }
        .anim-tray-fieldset legend {
            font-size: 0.6rem;
            padding: 0 2px;
        }

        
        .compact-input, .compact-select {
            padding: 1px 3px;
            font-size: 0.65rem;
            height: 19px;

        }
        .compact-input-grid {
            gap: 2px;
        }
        .p-mode-row-label, .legend-checkbox {
            font-size: 0.65rem;
            margin-bottom: 2px;
        }

        
        .waypoints-container {
            max-height: 42px; 
        }
        .waypoint-item {
            gap: 2px;
            margin-bottom: 2px;
        }
        .waypoint-remove-btn, .add-waypoint-btn {
            height: 18px;
        }
        .add-waypoint-btn {
            margin-top: 2px !important;
        }
        .logo {
            font-size: 28px; 
        }
        
        .accordion-header {
            font-size: 1.1rem; 
            font-weight: 700; 
        }
        
        label {
            font-size: 0.8rem; 
            font-weight: 500;
            color: var(--text-muted);
        }
        .btn-primary {
            background: var(--color-primary);
            box-shadow: 0 2px 10px rgba(88, 121, 248, 0.3); 
            transition: all 0.2s ease-in-out;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(88, 121, 248, 0.4);
        }
        
        .form-input {
            background: rgba(255, 255, 255, 0.07); 
            border-radius: 6px;
        }
        
        .tool-button {
            width: 52px; 
            height: 52px;
            border-radius: 12px;
        }
        .sidebar-content {
            padding: 2rem; 
        }
        
        .space-y-4 > * + * {
            margin-top: 1.25rem; 
        }
        .playground-object.is-plotting {
            position: relative;
            pointer-events: none; 
        }
        
        .playground-object.is-plotting::before {
            content: '';
            position: absolute;
            inset: 0;
            background: var(--bg-main-start);
            opacity: 0.7;
            border-radius: 12px;
            z-index: 1;
        }
        
        .playground-object.is-plotting::after {
            content: '';
            position: absolute;
            top: calc(50% - 12px);
            left: calc(50% - 12px);
            width: 24px;
            height: 24px;
            border: 3px solid var(--border-color);
            border-top-color: var(--color-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            z-index: 2;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        #info-modal-overlay {
            transition: opacity 0.2s ease-in-out;
        }
        #info-modal-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        #info-modal-panel {
            transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out;
        }
        #info-modal-overlay.hidden #info-modal-panel {
            transform: scale(0.95);
        }
        
        .info-slide {
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
            pointer-events: none;
        }
        .info-slide.active {
            opacity: 1;
            pointer-events: auto;
        }

        @media (max-width: 768px) and (orientation: portrait) {
            /* Hide the main application grid */
            .app-grid {
                display: none !important; 
            }
        
            /* Style and display the rotation prompt */
            #rotate-prompt {
                display: flex !important; /* Use !important to override other display properties */
                position: fixed;
                inset: 0;
                background-color: var(--bg-main-start);
                z-index: 9999;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                text-align: center;
                padding: 1rem;
            }
        }


        @media (max-width: 1200px) and (orientation: landscape) {
            body {
                overflow: auto;
            }
        
            .app-grid {
                width: 1920px;
                height: 1080px;
        
                --scale-x: calc(100vw / 1920px);
                --scale-y: calc(100vh / 1080px);
                --scale: min(var(--scale-x), var(--scale-y));
                
                /* Set your desired zoom level here */
                --zoom-factor: 1.0; 
        
                transform-origin: top left;
                transform: scale(calc(var(--scale) * var(--zoom-factor)));
            }
            
            #info-modal-overlay, #tutorial-modal-overlay, #calculator-popup {
                position: fixed;
                transform: none; 
            }
        }

        @keyframes rotate-device {
            0% {
              transform: rotate(0deg) scale(1);
            }
            15% {
              transform: rotate(15deg) scale(1.05);
            }
            30% {
              transform: rotate(75deg) scale(1.1);
            }
            50% {
              transform: rotate(90deg) scale(1.15);
            }
            70% {
              transform: rotate(90deg) scale(1.1);
            }
            85% {
              transform: rotate(15deg) scale(1.05);
            }
            100% {
              transform: rotate(0deg) scale(1);
            }
          }
          
          @keyframes glow-pulse {
            0%, 100% {
              filter: drop-shadow(0 0 8px rgba(59, 130, 246, 0.3));
            }
            50% {
              filter: drop-shadow(0 0 16px rgba(59, 130, 246, 0.6));
            }
          }
          
          @keyframes float {
            0%, 100% {
              transform: translateY(0px);
            }
            50% {
              transform: translateY(-10px);
            }
          }
          
          .animating-phone {
            transform-origin: center;
            animation: rotate-device 3s ease-in-out infinite;
          }
          
          .phone-container {
            animation: 
              glow-pulse 2s ease-in-out infinite,
              float 4s ease-in-out infinite;
          }

        
    </style>
</head>
<body class="">
    <div class="app-grid">

        <header class="top-bar flex items-center justify-between px-6 backdrop-blur-lg">
            <h1 class="logo">6AxisAnimation</h1>
            <div class="flex items-center gap-4" style="margin-left: 250px;">
                <div class="mode-tabs flex justify-end">
                    <button class="mode-tab" data-mode="playground">Playground</button>
                    <button class="mode-tab" data-mode="surface">Surface</button>
                    <button class="mode-tab" data-mode="parametric">Parametric</button>
                    <button class="mode-tab" data-mode="curve">Curve</button>
                    <button class="mode-tab" data-mode="implicit">Implicit</button>
                </div>
            </div>
            <div class="flex items-center gap-4">
                <div class="flex items-center bg-white/1 p-1 rounded-lg border border-white/10">
                    <label for="wireframe-toggle" class="tool-button icon-toggle-btn cursor-pointer !w-9 !h-9" title="Toggle Wireframe">
                        <input type="checkbox" id="wireframe-toggle" class="hidden">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3c-1.8 0-3.6.6-5 1.7l-7 5c-.6.5-.9 1.3-.9 2s.3 1.5.9 2l7 5c1.4 1.1 3.2 1.7 5 1.7s3.6-.6 5-1.7l7-5c.6-.5.9-1.3-.9-2s-.3-1.5-.9-2l-7-5C15.6 3.6 13.8 3 12 3z"/><path d="m22 7-8.9 5.1"/><path d="M2 7l8.9 5.1"/><path d="M12 22V12"/></svg>
                    </label>
                    <label for="grid-toggle" class="tool-button icon-toggle-btn cursor-pointer !w-9 !h-9 active" title="Toggle Axes & Grid">
                        <input type="checkbox" id="grid-toggle" class="hidden" checked>
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M3 9h18M9 3v18"/></svg>
                    </label>
                </div>
                <div class="flex items-center gap-2">
                    <div class="flex items-center bg-white/1 p-1 rounded-lg border border-white/10">
                        <button id="info-btn" class="tool-button !w-9 !h-9" title="Show Help">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>
                        </button>
                        <button id="theme-toggle" class="tool-button !w-9 !h-9" title="Toggle Theme">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/></svg>
                        </button>
                        <button id="zen-mode-toggle" class="tool-button !w-9 !h-9" title="Zen Mode">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 4.5l-10 10M9.5 4.5l10 10M4.5 9.5l10 10M4.5 14.5l-10-10"/></svg>
                        </button>
                        <button id="force-fullscreen-btn" class="tool-button !w-9 !h-9" title="Toggle Fullscreen">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>
                        </button>
                        <button class="btn btn-primary !p-2 !w-9 !h-9" id="share-btn" title="Copy a sharable link">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line></svg>
                        </button>
                    </div>
                </div>
            </div>
        </header>
    
        <aside class="left-panel backdrop-blur-lg">
            <div id="resize-handle"></div>
            <div class="sidebar-content p-6 space-y-6">
    
                <div id="single-mode-controls" class="space-y-4">
                    <div class="accordion">
                        <button class="accordion-header w-full text-left">
                            <span class="flex items-center gap-3">
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-secondary"><path d="M12 2a10 10 0 1 0 10 10c0-4.42-2.87-8.17-6.84-9.5c-.5-.1-.96-.6-.96-1.12V1.25C4.24 2.11 2 5.73 2 10a10 10 0 0 0 10 10Z"></path><path d="M12 12a2 2 0 1 0 4 0a2 2 0 1 0-4 0Z"></path></svg>
                                <span>Configuration</span>
                            </span>
                            <span class="chevron-container"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="chevron"><polyline points="6 9 12 15 18 9"></polyline></svg></span>
                        </button>
                        <div class="accordion-content">
                            <div class="space-y-5 pt-3">
                                <div class="surface-controls relative"></div>
                                <div class="parametric-controls hidden space-y-3 relative"></div>
                                <div class="curve-controls hidden space-y-3 relative"></div>
                                <div class="implicit-controls hidden space-y-3 relative"></div>
                            </div>
                        </div>
                    </div>
                     <div class="accordion">
                        <button class="accordion-header w-full text-left">
                            <span class="flex items-center gap-3">
                               <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-secondary"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="9" y1="21" x2="9" y2="9"></line></svg>
                               <span>Appearance</span>
                            </span>
                            <span class="chevron-container"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="chevron"><polyline points="6 9 12 15 18 9"></polyline></svg></span>
                        </button>
                        <div class="accordion-content">
                            <div class="space-y-5 pt-3" id="appearance-settings">
                            </div>
                        </div>
                        <div class="accordion-content">
                            <div class="space-y-5 pt-3">
                                <div class="surface-controls relative"></div>
                                <div class="vector-controls hidden space-y-3 relative"></div>
                                <div class="parametric-controls hidden space-y-3 relative"></div>
                                <div class="curve-controls hidden space-y-3 relative"></div>
                                <div class="implicit-controls hidden space-y-3 relative"></div>
                            </div>
                        </div>
                    </div>
                </div>
    
                <div id="playground-controls" class="space-y-4 hidden">
                    <div class="relative">
                        <button id="add-object-btn" class="btn btn-primary w-full">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
                            Add Object
                        </button>
                        <div id="add-object-menu" class="dropdown-menu w-full">
                            <div class="dropdown-item" data-type="surface">Explicit Surface</div>
                            <div class="dropdown-item" data-type="parametric">Parametric Surface</div>
                            <div class="dropdown-item" data-type="curve">Parametric Curve</div>
                            <div class="dropdown-item" data-type="vector">Vector Field</div>
                            <div class="dropdown-item" data-type="single-vector">Single Vector</div>
                            <div class="dropdown-item" data-type="implicit">Implicit Surface</div>
                        </div>
                    </div>
                    <div id="playground-objects-container" class="space-y-4"></div>
                </div>
                <div class="accordion" id="slicing-controls-accordion">
                    <button class="accordion-header w-full text-left">
                        <span class="flex items-center gap-3">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-secondary"><path d="M14.5 4.5l-10 10M9.5 4.5l10 10M4.5 9.5l10 10M4.5 14.5l-10-10"/></svg>
                            <span>Slicing Plane</span>
                        </span>
                        <span class="chevron-container"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="chevron"><polyline points="6 9 12 15 18 9"></polyline></svg></span>
                    </button>
                    <div class="accordion-content">
                        <div class="space-y-3 pt-3 p-2">
                            <label class="flex items-center gap-3 cursor-pointer">
                                <input type="checkbox" id="slicing-enabled-toggle" class="form-checkbox h-5 w-5 text-primary rounded">
                                <span class="font-medium">Enable Slicing</span>
                            </label>
                            <div class="slicing-axis-toggle flex bg-bg-input-focus rounded-lg p-1">
                                <input type="checkbox" id="slice-axis-x" value="x" class="hidden"><label for="slice-axis-x" class="flex-1 text-center py-1 text-sm font-semibold rounded-md cursor-pointer transition-colors">X</label>
                                <input type="checkbox" id="slice-axis-y" value="y" class="hidden"><label for="slice-axis-y" class="flex-1 text-center py-1 text-sm font-semibold rounded-md cursor-pointer transition-colors">Y</label>
                                <input type="checkbox" id="slice-axis-z" value="z" class="hidden"><label for="slice-axis-z" class="flex-1 text-center py-1 text-sm font-semibold rounded-md cursor-pointer transition-colors">Z</label>
                            </div>
                            <div>
                                <label class="text-sm">X Position: <span id="slice-position-value-x" class="font-mono text-secondary font-semibold">0.00</span></label>
                                <input type="range" id="slice-position-slider-x" min="-10" max="10" step="0.1" value="0" data-axis="x">
                            </div>
                            <div>
                                <label class="text-sm">Y Position: <span id="slice-position-value-y" class="font-mono text-secondary font-semibold">0.00</span></label>
                                <input type="range" id="slice-position-slider-y" min="-10" max="10" step="0.1" value="0" data-axis="y">
                            </div>
                            <div>
                                <label class="text-sm">Z Position: <span id="slice-position-value-z" class="font-mono text-secondary font-semibold">0.00</span></label>
                                <input type="range" id="slice-position-slider-z" min="-10" max="10" step="0.1" value="0" data-axis="z">
                            </div>
                        </div>
                    </div>
                </div>
                <div class="accordion" id="presets-accordion">
                    <button class="accordion-header w-full text-left">
                        <span class="flex items-center gap-3">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-secondary"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="9" y1="21" x2="9" y2="9"></line></svg>
                            <span id="presets-title">Presets</span>
                        </span>
                        <span class="chevron-container"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="chevron"><polyline points="6 9 12 15 18 9"></polyline></svg></span>
                    </button>
                    <div class="accordion-content"><div class="pt-3 grid grid-cols-2 sm:grid-cols-3 gap-3" id="presets-container"></div></div>
                </div>
            </div>
    
            <div class="p-4 mt-auto border-t border-white/10">
                <div class="bg-white/5 backdrop-blur-sm border border-white/10 rounded-lg p-3 mb-4">
                    <h3 class="text-sm font-bold text-blue-300 text-center uppercase tracking-wide">File Operations</h3>
                </div>
                <div class="grid grid-cols-5 gap-2">
                    <button class="btn btn-primary flex items-center justify-center h-12 min-w-[60px]" id="export-png" title="Export plot as PNG">
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <rect width="18" height="18" x="3" y="3" rx="2" ry="2"></rect>
                            <circle cx="9" cy="9" r="2"></circle>
                            <path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"></path>
                        </svg>
                    </button>
                    <button class="btn btn-secondary flex items-center justify-center h-12 min-w-[60px]" id="export-stl" title="Export focused object as STL">
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path>
                        </svg>
                    </button>
                    <button class="btn btn-secondary flex items-center justify-center h-12 min-w-[60px]" id="export-gltf" title="Export focused object as GLTF">
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"></path>
                        </svg>
                    </button>
                    <button class="btn btn-secondary flex items-center justify-center h-12 min-w-[60px]" id="save-settings" title="Save current settings">
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                            <polyline points="17 21 17 13 7 13 7 21"></polyline>
                            <polyline points="7 3 7 8 15 8"></polyline>
                        </svg>
                    </button>
                    <label class="btn btn-secondary flex items-center justify-center cursor-pointer h-12 min-w-[60px]" title="Load settings from file">
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                            <polyline points="14 2 14 8 20 8"></polyline>
                            <line x1="16" y1="13" x2="8" y2="13"></line>
                            <line x1="16" y1="17" x2="8" y2="17"></line>
                            <polyline points="10 9 9 9 8 9"></polyline>
                        </svg>
                        <input type="file" id="load-settings" accept=".json" class="hidden">
                    </label>
                </div>
            </div>
        </aside>
    
        <main class="main-viewport">
            <div id="view-controls" style="position: absolute; top: 1rem; right: 1rem; z-index: 100; display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.25rem; background: rgba(17, 24, 39, 0.2); backdrop-filter: blur(5px); padding: 0.3rem; border-radius: 0.6rem;">
                <button id="fit-view-btn" class="w-8 h-8 flex items-center justify-center rounded-md bg-transparent hover:bg-white/10 text-gray-400 hover:text-white/70 transition-colors text-xs opacity-90" title="Fit View to Objects">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 6H3m18 12H3"/>
                        <path d="M6 3v18M18 3v18"/>
                    </svg>
                </button>
                <button id="cam-top" class="w-8 h-8 flex items-center justify-center rounded-md bg-transparent hover:bg-white/10 text-gray-400 hover:text-white/70 transition-colors font-semibold text-xs opacity-70" title="Top View (Z)">Z</button>
                <button id="cam-side" class="w-8 h-8 flex items-center justify-center rounded-md bg-transparent hover:bg-white/10 text-gray-400 hover:text-white/70 transition-colors font-semibold text-xs opacity-70" title="Side View (X)">X</button>
                <button id="cam-front" class="w-8 h-8 flex items-center justify-center rounded-md bg-transparent hover:bg-white/10 text-gray-400 hover:text-white/70 transition-colors font-semibold text-xs opacity-70" title="Front View (Y)">Y</button>
            </div>
            
            <div id="plot-container" class="w-full h-full"></div>
    
            <button id="exit-zen-mode" class="exit-mode-btn">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6L6 18"/><path d="M6 6l12 12"/></svg>
                <span>Exit Zen</span>
            </button>
            <button id="exit-fullscreen-mode" class="exit-mode-btn">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6L6 18"/><path d="M6 6l12 12"/></svg>
                <span>Exit Fullscreen</span>
            </button>

            <div class="status-bar flex items-center justify-end px-6 gap-8">
                </div>
        </main>
    
        <div class="animation-tray-wrapper visible">
            <div id="global-animation-tray">
                <div style="position: absolute; bottom: 8px; left: 50%; transform: translateX(-50%); z-index: 30; display: flex; gap: 8px;">
                    <button class="btn btn-secondary p-2 h-10 w-10 rounded-full flex items-center justify-center" id="global-play-pause-btn" title="Play/Pause All Animations">
                        <svg id="global-play-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                            <polygon points="5 3 19 12 5 21 5 3"></polygon>
                        </svg>
                        <svg id="global-pause-icon" class="hidden" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="10" y1="15" x2="10" y2="9"></line><line x1="14" y1="15" x2="14" y2="9"></line>
                        </svg>
                    </button>
                    <button class="btn btn-secondary p-2 h-10 w-10 rounded-full flex items-center justify-center" id="global-reset-btn" title="Reset All Animations">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path><path d="M3 3v5h5"></path>
                        </svg>
                    </button>
                    <button class="btn btn-secondary p-2 h-10 w-10 rounded-full flex items-center justify-center" id="global-select-all-btn" title="Select All Override Variables">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="9 11 12 14 22 4"></polyline>
                            <path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path>
                        </svg>
                    </button>
                </div>
                <div id="animation-cards-container" class="w-full h-full flex flex-wrap content-start gap-4 overflow-y-auto p-4 pt-5"></div>
            </div>
        </div>
    
        <div id="toast" class="toast"></div>
    
    </div>


    

    <script id="worker-script" type="text/worker">
            var MarchingCubes = (function() {
                
                // http://paulbourke.net/geometry/polygonise/
                var MarchingCubes = function(resolution) {
                    this.resolution = resolution;
                    this.edgeTable = new Int32Array([0x0, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c, 0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00, 0x190, 0x99, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c, 0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90, 0x230, 0x339, 0x33, 0x13a, 0x636, 0x73f, 0x435, 0x53c, 0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30, 0x3a0, 0x2a9, 0x1a3, 0xaa, 0x7a6, 0x6af, 0x5a5, 0x4ac, 0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0, 0x460, 0x569, 0x663, 0x76a, 0x66, 0x16f, 0x265, 0x36c, 0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60, 0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff, 0x3f5, 0x2fc, 0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0, 0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55, 0x15c, 0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950, 0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc, 0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0, 0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc, 0xcc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0, 0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c, 0x15c, 0x55, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650, 0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc, 0x2fc, 0x3f5, 0xff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0, 0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c, 0x36c, 0x265, 0x16f, 0x66, 0x76a, 0x663, 0x569, 0x460, 0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac, 0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa, 0x1a3, 0x2a9, 0x3a0, 0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c, 0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33, 0x339, 0x230, 0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c, 0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99, 0x190, 0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c, 0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0]);
                    this.triTable = new Int32Array([-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 0, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 1, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 0, 9, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, 11, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 2, 11, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 3, 11, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 8, 3, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 8, 3, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 8, 3, 2, 10, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 8, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 11, 8, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 11, 8, 10, 2, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 7, 8, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 7, 8, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 9, 0, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, 4, 7, 8, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 11, 1, 9, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, 0, 3, 11, 10, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 3, 11, 10, 4, 7, 8, 1, 9, -1, -1, -1, -1, -1, -1, -1, 4, 7, 3, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 4, 7, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 4, 7, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 4, 7, 2, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 7, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 7, 11, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 4, 7, 11, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 2, 1, 4, 7, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, 4, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 5, 4, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 5, 4, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 5, 4, 11, 3, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 5, 4, 0, 10, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, 4, 11, 3, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 5, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, 3, 8, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 5, 4, 3, 8, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, 2, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, 11, 5, 4, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 5, 4, 8, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 5, 4, 8, 2, 10, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, 4, 2, 10, 9, 11, 8, 3, -1, -1, -1, -1, -1, -1, -1, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, 5, 10, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, 5, 1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, 5, 1, 2, 9, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, 5, 10, 3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, 5, 10, 9, 0, 1, 11, 3, 2, -1, -1, -1, -1, -1, -1, -1, 6, 5, 1, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 6, 5, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, 5, 10, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, 5, 10, 9, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, 5, 1, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, 5, 1, 9, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, 5, 10, 11, 8, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, 5, 10, 9, 11, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, 5, 1, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, 5, 1, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, 4, 7, 0, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 6, 4, 7, 1, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 0, 1, 6, 4, 7, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, 3, 6, 4, 7, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 0, 1, 6, 4, 7, 11, 3, 2, -1, -1, -1, -1, -1, -1, -1, 0, 3, 11, 10, 6, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 6, 4, 10, 1, 9, 11, 3, 0, -1, -1, -1, -1, -1, -1, -1, 8, 6, 4, 7, 3, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 6, 4, 7, 9, 0, 1, 3, -1, -1, -1, -1, -1, -1, -1, -1, 8, 6, 4, 7, 1, 2, 10, 3, 0, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 9, 8, 6, 4, 7, 3, 0, -1, -1, -1, -1, -1, -1, 11, 6, 4, 7, 8, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 6, 4, 7, 9, 0, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, 11, 6, 4, 7, 1, 2, 10, 8, 0, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 9, 11, 6, 4, 7, 8, 0, -1, -1, -1, -1, -1, -1, 9, 5, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 5, 7, 6, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 5, 7, 6, 10, 2, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 5, 7, 6, 10, 2, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, 11, 5, 7, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 5, 7, 6, 2, 11, 0, 1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 5, 7, 6, 0, 8, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, 7, 6, 0, 8, 11, 2, 9, 10, -1, -1, -1, -1, -1, -1, 3, 5, 7, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 5, 7, 6, 8, 3, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 5, 7, 6, 8, 3, 1, 2, -1, -1, -1, -1, -1, -1, -1, -1, 9, 5, 7, 6, 8, 3, 1, 2, 10, 0, -1, -1, -1, -1, -1, -1, 11, 5, 7, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 5, 7, 6, 8, 0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 5, 7, 6, 8, 2, 10, 0, -1, -1, -1, -1, -1, -1, -1, -1, 1, 5, 7, 6, 8, 2, 10, 9, 11, 0, -1, -1, -1, -1, -1, -1, 7, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 2, 10, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 2, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 2, 1, 0, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 2, 10, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 2, 10, 1, 9, 0, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, 7, 2, 1, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 2, 1, 0, 9, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 2, 10, 8, 0, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 2, 10, 9, 0, 1, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, 7, 2, 1, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 2, 1, 9, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 2, 10, 11, 8, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 11, 8, 7, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, 7, 2, 1, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 2, 1, 0, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 6, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 6, 3, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 6, 3, 10, 2, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 9, 1, 10, 2, 11, 6, 3, -1, -1, -1, -1, -1, -1, -1, -1, 11, 6, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 2, 1, 11, 6, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 6, 0, 1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 6, 3, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 6, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 6, 3, 8, 2, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 6, 3, 8, 1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, 0, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, 2, 8, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, 2, 8, 10, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 6, 3, 7, 4, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 6, 3, 7, 4, 8, 0, 9, 1, -1, -1, -1, -1, -1, -1, -1, 11, 6, 3, 7, 4, 8, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 0, 9, 11, 6, 3, 7, 4, 8, -1, -1, -1, -1, -1, 11, 6, 0, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 11, 6, 7, 4, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 2, 10, 11, 6, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 11, 6, 7, 4, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 4, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 7, 4, 8, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 7, 4, 8, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 7, 4, 8, 6, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 6, 11, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 6, 11, 8, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 9, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 9, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 9, 5, 1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 9, 5, 2, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 9, 5, 11, 3, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 9, 5, 0, 1, 11, 3, 2, -1, -1, -1, -1, -1, -1, -1, -1, 10, 9, 5, 2, 0, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 9, 5, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 5, 9, 0, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 5, 9, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 5, 9, 2, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 5, 9, 0, 10, 3, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 5, 9, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 8, 5, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 8, 5, 9, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 8, 5, 9, 0, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 6, 7, 0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 6, 7, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 0, 9, 2, 10, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, 11, 6, 7, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 6, 7, 0, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 6, 7, 0, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 11, 6, 7, 0, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 6, 7, 8, 0, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 6, 7, 9, 0, 1, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, 11, 6, 7, 10, 2, 1, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1, 11, 6, 7, 9, 0, 1, 8, 3, 2, 10, -1, -1, -1, -1, -1, -1, 11, 6, 7, 8, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 11, 6, 7, 8, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 6, 7, 8, 0, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 11, 6, 7, 8, 0, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, 11, 6, 7, 9, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 6, 7, 9, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 6, 7, 9, 5, 10, 2, 1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 6, 7, 9, 5, 1, 0, 2, 10, -1, -1, -1, -1, -1, -1, -1, 11, 6, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 6, 7, 5, 0, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 6, 7, 5, 10, 2, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 11, 6, 7, 5, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 6, 7, 8, 3, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 11, 6, 7, 8, 3, 5, 9, 0, -1, -1, -1, -1, -1, -1, -1, 11, 6, 7, 10, 2, 8, 3, 5, 0, 1, -1, -1, -1, -1, -1, -1, 1, 11, 6, 7, 5, 2, 10, 9, 8, 3, 0, -1, -1, -1, -1, -1, 11, 6, 7, 8, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 11, 6, 7, 8, 5, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 11, 6, 7, 8, 5, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, 1, 11, 6, 7, 8, 5, 2, 10, 9, -1, -1, -1, -1, -1, -1, -1, 10, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 6, 7, 2, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 6, 7, 2, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 6, 7, 2, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 6, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 3, 11, 10, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, 10, 6, 7, 2, 1, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 11, 3, 10, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, 10, 6, 7, 2, 8, 0, 3, -1, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 8, 3, 10, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, 10, 6, 7, 2, 1, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 8, 3, 10, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, 10, 6, 7, 2, 11, 8, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 11, 8, 10, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, 10, 6, 7, 2, 1, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 11, 8, 10, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, 10, 9, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 9, 7, 6, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 9, 7, 6, 1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 9, 7, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 9, 7, 6, 3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 9, 7, 6, 0, 1, 11, 3, 2, -1, -1, -1, -1, -1, -1, -1, 10, 9, 7, 6, 2, 0, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 9, 7, 6, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, 10, 9, 7, 6, 8, 0, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 9, 7, 6, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 9, 7, 6, 8, 3, 1, 2, -1, -1, -1, -1, -1, -1, -1, -1, 10, 9, 7, 6, 8, 3, 2, 0, -1, -1, -1, -1, -1, -1, -1, -1, 10, 9, 7, 6, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 9, 7, 6, 11, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 9, 7, 6, 11, 8, 2, 0, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 9, 7, 6, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1]);
                };
                MarchingCubes.prototype.vertex_interp = function(isolevel, p1, p2, valp1, valp2) {
                    var mu = (isolevel - valp1) / (valp2 - valp1);
                    return { x: p1.x + mu * (p2.x - p1.x), y: p1.y + mu * (p2.y - p1.y), z: p1.z + mu * (p2.z - p1.z) };
                };
                MarchingCubes.prototype.march = function(data, isolevel) {
                    var res = this.resolution, res2 = res*res;
                    var verts = [], faces = [];
                    var vertlist = new Array(12);
                    for (var z = 0; z < res - 1; z++) {
                        for (var y = 0; y < res - 1; y++) {
                            for (var x = 0; x < res - 1; x++) {
                                var p = x + y * res + z * res2;
                                var cubeindex = 0;
                                if (data[p] < isolevel) cubeindex |= 1;
                                if (data[p + 1] < isolevel) cubeindex |= 2;
                                if (data[p + res + 1] < isolevel) cubeindex |= 4;
                                if (data[p + res] < isolevel) cubeindex |= 8;
                                if (data[p + res2] < isolevel) cubeindex |= 16;
                                if (data[p + res2 + 1] < isolevel) cubeindex |= 32;
                                if (data[p + res2 + res + 1] < isolevel) cubeindex |= 64;
                                if (data[p + res2 + res] < isolevel) cubeindex |= 128;
                                var bits = this.edgeTable[cubeindex];
                                if (bits === 0) continue;
                                var p1 = {x:x,y:y,z:z}, p2={x:x+1,y:y,z:z}, p3={x:x+1,y:y+1,z:z}, p4={x:x,y:y+1,z:z}, p5={x:x,y:y,z:z+1}, p6={x:x+1,y:y,z:z+1}, p7={x:x+1,y:y+1,z:z+1}, p8={x:x,y:y+1,z:z+1};
                                if (bits & 1) vertlist[0] = this.vertex_interp(isolevel, p1, p2, data[p], data[p + 1]);
                                if (bits & 2) vertlist[1] = this.vertex_interp(isolevel, p2, p3, data[p + 1], data[p + res + 1]);
                                if (bits & 4) vertlist[2] = this.vertex_interp(isolevel, p3, p4, data[p + res + 1], data[p + res]);
                                if (bits & 8) vertlist[3] = this.vertex_interp(isolevel, p4, p1, data[p + res], data[p]);
                                if (bits & 16) vertlist[4] = this.vertex_interp(isolevel, p5, p6, data[p + res2], data[p + res2 + 1]);
                                if (bits & 32) vertlist[5] = this.vertex_interp(isolevel, p6, p7, data[p + res2 + 1], data[p + res2 + res + 1]);
                                if (bits & 64) vertlist[6] = this.vertex_interp(isolevel, p7, p8, data[p + res2 + res + 1], data[p + res2 + res]);
                                if (bits & 128) vertlist[7] = this.vertex_interp(isolevel, p8, p5, data[p + res2 + res], data[p + res2]);
                                if (bits & 256) vertlist[8] = this.vertex_interp(isolevel, p1, p5, data[p], data[p + res2]);
                                if (bits & 512) vertlist[9] = this.vertex_interp(isolevel, p2, p6, data[p + 1], data[p + res2 + 1]);
                                if (bits & 1024) vertlist[10] = this.vertex_interp(isolevel, p3, p7, data[p + res + 1], data[p + res2 + res + 1]);
                                if (bits & 2048) vertlist[11] = this.vertex_interp(isolevel, p4, p8, data[p + res], data[p + res2 + res]);
                                
                                var i = 0;
                                cubeindex <<= 4;
                                
                                while ((cubeindex + i) < this.triTable.length && this.triTable[cubeindex + i] !== -1) {
                                    
                                    const index1 = this.triTable[cubeindex + i];
                                    const index2 = this.triTable[cubeindex + i + 1];
                                    const index3 = this.triTable[cubeindex + i + 2];
                                
                                    
                                    const v1 = vertlist[index1];
                                    const v2 = vertlist[index2];
                                    const v3 = vertlist[index3];
                                
                                    
                                    
                                    if (v1 && v2 && v3) {
                                        
                                        const baseIndex = verts.length;
                                
                                        
                                        verts.push(v1, v2, v3);
                                        
                                        
                                        faces.push(baseIndex, baseIndex + 1, baseIndex + 2);
                                    }
                                    
                                    
                                    i += 3;
                                }
                            }
                        }
                    }
                    return { vertices: verts, faces: faces };
                };
                return MarchingCubes;
            })();
    
        self.importScripts('https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.5.0/math.min.js');
        const linspace=(start,end,num)=>{if(num===0)return[];if(num<=1)return[start];const t=(end-start)/(num-1);return Array.from({length:num},(_,r)=>start+t*r)};
        
        function generateImplicitData({ equation: eq, xMin, xMax, yMin, yMax, zMin, zMax, quality, scope, xMaxOverride, yMaxOverride, zMaxOverride, slicingEnabled, sliceAxes, slicePositions }) {
            const p = math.parse(eq).compile();
            const size = quality * quality * quality;
        
            if (size <= 0 || !isFinite(size)) {
                throw new Error("Invalid quality setting produced a non-positive array size.");
            }
            const d = new Float32Array(size);
        
            let minVal = Infinity, maxVal = -Infinity;
        
            const finalXMax = xMaxOverride !== undefined ? xMaxOverride : xMax;
            const finalYMax = yMaxOverride !== undefined ? yMaxOverride : yMax;
            const finalZMax = zMaxOverride !== undefined ? zMaxOverride : zMax;
        
            const x_step = (finalXMax - xMin) / (quality - 1);
            const y_step = (finalYMax - yMin) / (quality - 1);
            const z_step = (finalZMax - zMin) / (quality - 1);
        
            const sliceWidth = Math.max(x_step, y_step, z_step) * 2.5;
        
            let index = 0;
            for (let k = 0; k < quality; k++) { 
                for (let j = 0; j < quality; j++) { 
                    for (let i = 0; i < quality; i++) { 
                        const x_coord = xMin + i * x_step;
                        const y_coord = yMin + j * y_step;
                        const z_coord = zMin + k * z_step;
        
                        
                        if (slicingEnabled && sliceAxes && sliceAxes.length > 0) {
                            let isOutsideSlice = false;
                            
                            for (const axis of sliceAxes) {
                                const coord = { x: x_coord, y: y_coord, z: z_coord }[axis];
                                const position = slicePositions[axis];
                                if (Math.abs(coord - position) > sliceWidth / 2) {
                                    isOutsideSlice = true;
                                    break; 
                                }
                            }
                            if (isOutsideSlice) {
                                d[index++] = 1e6;
                                continue;
                            }
                        }
                        
        
                        try {
                            const val = p.evaluate({ ...scope, x: x_coord, y: y_coord, z: z_coord });
                            if (isFinite(val)) {
                                d[index++] = val;
                                if (val < minVal) minVal = val;
                                if (val > maxVal) maxVal = val;
                            } else {
                                d[index++] = 1e6;
                            }
                        } catch (err) {
                            d[index++] = 1e6;
                        }
                    }
                }
            }
            const marchingCubes = new MarchingCubes(quality);
            const result = marchingCubes.march(d, 0);
        
            result.vertices.forEach(v => {
                v.x = xMin + v.x * x_step;
                v.y = yMin + v.y * y_step;
                v.z = zMin + v.z * z_step;
            });
        
            return { data: { vertices: result.vertices, faces: result.faces, zMin: minVal, zMax: maxVal }, stats: { dataPoints: result.vertices.length } };
        }

        self.onmessage=function(e){
            const t=e.data;
            try{
                let r;
                switch(t.mode){
                    case"surface":r=generateSurfaceData(t);break;
                    case"vector":r=generateVectorData(t);break;
                    case"parametric":r=generateParametricData(t);break;
                    case"curve":r=generateParametricCurveData(t);break;
                    case"implicit":r=generateImplicitData(t);break

                }
                self.postMessage({status:"success",data:r.data,stats:r.stats,id:t.id})
            }catch(r){
                self.postMessage({status:"error",message:r.message,id:t.id})
            }
        };

        function generateSurfaceData({equation:e,xMin:t,xMax:r,yMin:a,yMax:n,quality:o,xMaxOverride:i,yMaxOverride:l,scope:s}){const c=void 0!==i?i:r,d=void 0!==l?l:n,p=linspace(t,c,o),m=linspace(a,d,o),h=math.parse(e).compile(),f=[],g=[];let u=1/0,v=-1/0;for(const e of m)for(const t of p)try{const r=h.evaluate({...s,x:t,y:e});isFinite(r)?(f.push(t,e,r),g.push(r),r<u&&(u=r),r>v&&(v=r)):(f.push(t,e,0),g.push(NaN))}catch(err){f.push(t,e,0),g.push(NaN)}const w=[];for(let e=0;e<o-1;e++)for(let t=0;t<o-1;t++){const r=e*o+t,a=r+1,n=r+o,s=n+1;w.push(r,n,a),w.push(a,n,s)}return{data:{vertices:new Float32Array(f),indices:new Uint32Array(w),values:new Float32Array(g),width:o,height:o,zMin:u,zMax:v},stats:{dataPoints:o*o}}}
        function generateVectorData({fx:e,fy:t,fz:r,xMin:a,xMax:n,yMin:o,yMax:s,zMin:i,zMax:l,density:c,xMaxOverride:d,yMaxOverride:p,zMaxOverride:h,scope:m}){const g=void 0!==d?d:n,f=void 0!==p?p:s,q=void 0!==h?h:l,v=linspace(a,g,c),b=linspace(o,f,c),w=linspace(i,q,c),y=math.parse(e).compile(),x=math.parse(t).compile(),E=math.parse(r).compile(),M=[],S=c*c*c;let z=1/0,A=-1/0;for(const e of v)for(const t of b)for(const r of w)try{const a={...m,x:e,y:t,z:r},n=y.evaluate(a),o=x.evaluate(a),s=E.evaluate(a);if([n,o,s].every(isFinite)){const i=Math.sqrt(n*n+o*o+s*s);i>1e-6&&(i<z&&(z=i),i>A&&(A=i),M.push({origin:{x:e,y:t,z:r},components:{x:n,y:o,z:s},mag:i}))}}catch(err){}z===1/0&&(z=0);const V={vectors:M,minMag:z,maxMag:A,domain:{xMin:a,xMax:n,yMin:o,yMax:s,zMin:i,zMax:l},density:c};return{data:V,stats:{dataPoints:M.length}}}
        function generateParametricData({xExpr:e,yExpr:t,zExpr:r,uMin:a,uMax:n,vMin:o,vMax:s,quality:i,uMaxOverride:c,vMaxOverride:d,scope:p}){const h=void 0!==c?c:n,m=void 0!==d?d:s,f=linspace(a,h,i),g=linspace(o,m,i),q=math.parse(e).compile(),v=math.parse(t).compile(),b=math.parse(r).compile(),w=[],y=[];let x=1/0,E=-1/0;for(const e of g)for(const t of f)try{const r={...p,u:t,v:e},a=q.evaluate(r),n=v.evaluate(r),o=b.evaluate(r);[a,n,o].every(isFinite)?(w.push(a,n,o),y.push(o),o<x&&(x=o),o>E&&(E=o)):(w.push(0,0,0),y.push(NaN))}catch(err){w.push(0,0,0),y.push(NaN)}const M=[];for(let e=0;e<i-1;e++)for(let t=0;t<i-1;t++){const r=e*i+t,a=r+1,n=r+i,o=n+1;M.push(r,n,a),M.push(a,n,o)}return{data:{vertices:new Float32Array(w),indices:new Uint32Array(M),values:new Float32Array(y),width:i,height:i,zMin:x,zMax:E},stats:{dataPoints:i*i}}}
        function generateParametricCurveData({xExpr:e,yExpr:t,zExpr:r,tMin:a,tMax:n,quality:o,tMaxOverride:i,scope:l}){const c=void 0!==i?i:n,s=linspace(a,c,o),d=math.parse(e).compile(),p=math.parse(t).compile(),h=math.parse(r).compile(),m=[],f=[];for(const e of s)try{const t={...l,t:e},r=d.evaluate(t),n=p.evaluate(t),a=h.evaluate(t);[r,n,a].every(isFinite)&&(m.push(r,n,a),f.push(e))}catch(err){}return{data:{vertices:new Float32Array(m),values:new Float32Array(f),tMin:a,tMax:c},stats:{dataPoints:m.length/3}}}
       
    </script>
    <script>
        
        class ThreeJSPlotter {
            constructor(appController) {
                this.app = appController;
                this.container = document.getElementById('plot-container');
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, this.container.clientWidth / this.container.clientHeight, 0.1, 1000);
                this.camera.up.set(0, 0, 1);
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, logarithmicDepthBuffer: true });
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.hudCanvas = null;
                this.hudContext = null;
                this.hudTexture = null;
                this.hudScene = new THREE.Scene();
                this.hudCamera = null;
                this.hudSprite = null;
                this.plotGroup = new THREE.Group();
                this.axesGroup = new THREE.Group();
                this.renderDirty = true;
                this.pathVisualizerGroup = new THREE.Group();
                this.clipPlane = new THREE.Plane(new THREE.Vector3(1, 0, 0), 0);
                this.init();
            }
        
            init() {
                this.renderer.localClippingEnabled = true;
                this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.container.appendChild(this.renderer.domElement);
                this.camera.position.set(-10, 0, 5);
                this.camera.lookAt(0, 0, 0);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.1;
                this.controls.minDistance = 0.5; 
                this.controls.maxDistance = 500; 
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(1, 1, 1);
                this.scene.add(directionalLight);
                this.scene.add(this.plotGroup);
                this.scene.add(this.axesGroup);
                this.scene.add(this.pathVisualizerGroup);
                this.controls.enableZoom = true;
                this.initHUD();
                window.addEventListener('resize', () => this.onResize());
                this.container.addEventListener('mousemove', (e) => this.onMouseMove(e), false);
                this.updateTheme();
                this.animate();
            }
        
            onResize() {
                const width = this.container.clientWidth;
                const height = this.container.clientHeight;
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                if (this.hudCamera) {
                    this.hudCamera.left = -width / 2;
                    this.hudCamera.right = width / 2;
                    this.hudCamera.top = height / 2;
                    this.hudCamera.bottom = -height / 2;
                    this.hudCamera.updateProjectionMatrix();
                    this.updateHUDPosition();
                }
                this.renderer.setSize(width, height);
                this.renderDirty = true;
            }
        
            initHUD() {
                const width = this.container.clientWidth;
                const height = this.container.clientHeight;
                this.hudCamera = new THREE.OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, 1, 10);
                this.hudCamera.position.z = 10;
                this.hudCanvas = document.createElement('canvas');
                this.hudCanvas.width = 300;
                this.hudCanvas.height = 24;
                this.hudContext = this.hudCanvas.getContext('2d');
                this.hudContext.font = "14px 'JetBrains Mono', monospace";
                this.hudContext.textAlign = 'left';
                this.hudContext.textBaseline = 'middle';
                this.hudTexture = new THREE.CanvasTexture(this.hudCanvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: this.hudTexture, transparent: true });
                this.hudSprite = new THREE.Sprite(spriteMaterial);
                this.hudSprite.scale.set(this.hudCanvas.width, this.hudCanvas.height, 1.0);
                this.hudScene.add(this.hudSprite);
                this.updateHUDText('Hover for coordinates...');
                this.updateHUDPosition();
            }
        
            updateHUDText(text) {
                if (!this.hudContext || !this.hudCanvas || !this.hudTexture) return;
                this.hudContext.clearRect(0, 0, this.hudCanvas.width, this.hudCanvas.height);
                this.hudContext.fillStyle = document.body.classList.contains('light-theme') ? "rgba(0,0,0,0.7)" : "rgba(255, 255, 255, 0.7)";
                this.hudContext.fillText(text, 5, this.hudCanvas.height / 2);
                this.hudTexture.needsUpdate = true;
                this.renderDirty = true;
            }
        
            updateHUDPosition() {
                if (!this.hudSprite || !this.hudCamera) return;
                const width = this.container.clientWidth;
                const height = this.container.clientHeight;
                const margin = 20;
                const posX = -width / 2 + this.hudSprite.scale.x / 2 + margin;
                const posY = -height / 2 + this.hudSprite.scale.y / 2 + margin;
                this.hudSprite.position.set(posX, posY, 1);
            }
        
            onMouseMove(event) {
                const rect = this.container.getBoundingClientRect();
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const visibleObjects = this.plotGroup.children.filter(c => c.visible);
                const intersects = this.raycaster.intersectObjects(visibleObjects, true);
                if (intersects.length > 0) {
                    const p = intersects[0].point;
                    this.app.updateCoords(`Point: (${p.x.toFixed(2)}, ${p.y.toFixed(2)}, ${p.z.toFixed(2)})`);
                } else {
                    this.app.updateCoords(null);
                }
            }
        
            animate() {
                requestAnimationFrame(() => this.animate());
                const controlsUpdated = this.controls.update();
                if (controlsUpdated || this.renderDirty) {
                    this.renderer.autoClear = false;
                    this.renderer.clear();
                    this.renderer.render(this.scene, this.camera);
                    this.renderer.clearDepth();
                    this.renderer.render(this.hudScene, this.hudCamera);
                    this.renderDirty = false;
                }
            }
        
            clearPlots() {
                while (this.plotGroup.children.length > 0) {
                    const obj = this.plotGroup.children[0];
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) {
                        if (Array.isArray(obj.material)) obj.material.forEach(m => m.dispose());
                        else {
                            if (obj.material.map) obj.material.map.dispose();
                            obj.material.dispose();
                        }
                    }
                    this.plotGroup.remove(obj);
                }
                this.clearAxes();
                this.clearPathVisualizers();
            }
        
            clearAxes() {
                while (this.axesGroup.children.length > 0) {
                    const axisObject = this.axesGroup.children[0];
                    if (axisObject.geometry) axisObject.geometry.dispose();
                    if (axisObject.material) {
                        if (axisObject.material.map) axisObject.material.map.dispose();
                        axisObject.material.dispose();
                    }
                    this.axesGroup.remove(axisObject);
                }
            }
        
            clearPathVisualizers() {
                while (this.pathVisualizerGroup.children.length > 0) {
                    const pathObject = this.pathVisualizerGroup.children[0];
                    if (pathObject.geometry) pathObject.geometry.dispose();
                    if (pathObject.material) pathObject.material.dispose();
                    this.pathVisualizerGroup.remove(pathObject);
                }
            }

            setGridBounds(newBounds) {
                // This is a simplified version of updateAxesAndGrid that uses specific bounds
                this.clearAxes();
            
                const bounds = newBounds; // Use the passed-in bounds
                if (!isFinite(bounds.min.x) || bounds.isEmpty()) {
                    // Fallback if bounds are invalid
                    bounds.set(new THREE.Vector3(-10, -10, -10), new THREE.Vector3(10, 10, 10));
                }
            
                const isLightTheme = document.body.classList.contains('light-theme');
                const gridColor = isLightTheme ? 0xCBD5E1 : 0x374151;
                const textColor = isLightTheme ? '#0f172a' : '#f1f5f9';
                const sizeVec = bounds.getSize(new THREE.Vector3());
            
                const grid = new THREE.GridHelper(30, 30, gridColor, gridColor);
                grid.rotation.x = Math.PI / 2;
                grid.scale.set(sizeVec.x / 30, sizeVec.y / 30, 1);
                grid.position.set(0, 0, 0);
                grid.material.opacity = 0.50;
                grid.material.transparent = true;
                this.axesGroup.add(grid);
            
                const axisConfig = [
                    { name: 'X', color: 0xaa4444, dir: new THREE.Vector3(1, 0, 0) },
                    { name: 'Y', color: 0x44aa44, dir: new THREE.Vector3(0, 1, 0) },
                    { name: 'Z', color: 0x4444aa, dir: new THREE.Vector3(0, 0, 1) }
                ];
            
                axisConfig.forEach(({ name, color, dir }) => {
                    const axisName = name.toLowerCase();
                    const material = new THREE.LineBasicMaterial({ color: color });
                    const lineStart = dir.clone().multiplyScalar(bounds.min[axisName]);
                    const lineEnd = dir.clone().multiplyScalar(bounds.max[axisName]);
                    const geometry = new THREE.BufferGeometry().setFromPoints([lineStart, lineEnd]);
                    const line = new THREE.Line(geometry, material);
                    this.axesGroup.add(line);
                    const labelPos = lineEnd.clone().multiplyScalar(1.1);
                    this.axesGroup.add(this.createLabel(name, labelPos, textColor, 48));
                    const ticks = this.calculateNiceTicks(bounds.min[axisName], bounds.max[axisName]);
                    ticks.forEach(tickVal => {
                        if (Math.abs(tickVal) < 1e-9) return;
                        const tickPos = dir.clone().multiplyScalar(tickVal);
                        const tickSize = sizeVec.length() * 0.01;
                        const orthoDir = name === 'Z' ? new THREE.Vector3(1, 0, 0) : new THREE.Vector3(0, 0, 1);
                        const tickGeom = new THREE.BufferGeometry().setFromPoints([
                            tickPos.clone().sub(orthoDir.clone().multiplyScalar(tickSize)),
                            tickPos.clone().add(orthoDir.clone().multiplyScalar(tickSize))
                        ]);
                        const tickLine = new THREE.LineSegments(tickGeom, material);
                        this.axesGroup.add(tickLine);
                        const labelOffset = orthoDir.clone().multiplyScalar(tickSize * 2.5);
                        const numLabel = this.createLabel(tickVal.toString(), tickPos.clone().add(labelOffset), textColor, 32);
                        this.axesGroup.add(numLabel);
                    });
                });
            
                this.renderDirty = true;
            }
        
            renderAllPlots() {
                this.plotGroup.children.forEach(child => {
                    const plotObject = this.app.getPlaygroundObjectByMesh(child);
                    if (plotObject) {
                        child.visible = plotObject.visible;
                    }
                });
                this.updateAxesAndGrid();
            }
        
            updateSinglePlot(obj, isWireframe) {
                let newMesh;
                switch (obj.type) {
                    case 'surface':
                    case 'parametric':
                        if (obj.lastData) newMesh = this.createSurfaceMesh(obj, isWireframe);
                        break;
                    case 'curve':
                        if (obj.lastData) newMesh = this.createCurveMesh(obj);
                        break;
                    case 'vector':
                        if (obj.lastData) newMesh = this.createVectorMesh(obj);
                        break;
                    case 'implicit':
                        if (obj.lastData) newMesh = this.createImplicitMesh(obj, isWireframe);
                        break;
                    case 'single-vector':
                        newMesh = this.createSingleVectorMesh(obj);
                        break;
                }
                if (newMesh) {
                    newMesh.userData.objectId = obj.id;
                    if (obj.threeMesh) {
                        if (obj.threeMesh.geometry) obj.threeMesh.geometry.dispose();
                        if (obj.threeMesh.material) {
                            if (Array.isArray(obj.threeMesh.material)) obj.threeMesh.material.forEach(m => m.dispose());
                            else {
                                if (obj.threeMesh.material.map) obj.threeMesh.material.map.dispose();
                                obj.threeMesh.material.dispose();
                            }
                        }
                        this.plotGroup.remove(obj.threeMesh);
                    }
                    obj.threeMesh = newMesh;
                    if (obj.visible) {
                        this.plotGroup.add(obj.threeMesh);
                    }
                }
                this.updateAxesAndGrid();
            }
        
            calculateObjectBounds(mesh) {
                const boundingBox = new THREE.Box3();
                if (!mesh) return boundingBox;
                if (mesh.type === 'ArrowHelper') {
                    boundingBox.expandByPoint(mesh.position);
                    const endPoint = new THREE.Vector3().fromBufferAttribute(mesh.line.geometry.attributes.position, 1);
                    endPoint.applyMatrix4(mesh.matrixWorld);
                    boundingBox.expandByPoint(endPoint);
                } else if (mesh.geometry) {
                    if (!mesh.geometry.boundingBox) {
                        mesh.geometry.computeBoundingBox();
                    }
                    if (mesh.geometry.boundingBox) {
                        const meshBBox = mesh.geometry.boundingBox.clone();
                        meshBBox.applyMatrix4(mesh.matrixWorld);
                        boundingBox.union(meshBBox);
                    }
                }
                return boundingBox;
            }
        
            createLabel(text, position, color, fontSize = 32, background = false) {
                const isLightTheme = document.body.classList.contains('light-theme');
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                const font = `bold ${fontSize}px Inter, sans-serif`;
                context.font = font;
                const metrics = context.measureText(text);
                const textWidth = metrics.width;
                canvas.width = textWidth + (fontSize * 0.2);
                canvas.height = fontSize + (fontSize * 0.2);
                context.font = font;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                if (background) {
                    context.fillStyle = isLightTheme ? "rgba(241, 245, 249, 0.7)" : "rgba(21, 21, 36, 0.7)";
                    context.fillRect(0, 0, canvas.width, canvas.height);
                }
                context.fillStyle = color;
                context.fillText(text, canvas.width / 2, canvas.height / 2);
                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.SpriteMaterial({ map: texture, depthTest: false });
                const sprite = new THREE.Sprite(material);
                sprite.position.copy(position);
                const scale = canvas.height / 128;
                sprite.scale.set(scale * (canvas.width / canvas.height), scale, 1);
                return sprite;
            }
        
            calculateNiceTicks(min, max, maxTicks = 8) {
                if (min === max) return [min];
                const range = max - min;
                if (range === 0) return [min];
                const tickSpacing = range / (maxTicks - 1);
                const exponent = Math.floor(Math.log10(tickSpacing));
                const powerOf10 = Math.pow(10, exponent);
                const niceFraction = [1, 2, 2.5, 5, 10].find(f => (powerOf10 * f) > tickSpacing) || 10;
                const niceTickSpacing = niceFraction * powerOf10;
                const startTick = Math.floor(min / niceTickSpacing) * niceTickSpacing;
                const ticks = [];
                for (let i = startTick; i <= max * 1.001; i += niceTickSpacing) {
                    ticks.push(parseFloat(i.toPrecision(15)));
                }
                return ticks;
            }
        
            updateAxesAndGrid() {
                if (this.app.isBatchUpdating) return;
                this.clearAxes();
                let bounds = new THREE.Box3(
                    new THREE.Vector3(-10, -10, -10),
                    new THREE.Vector3(10, 10, 10)
                );
                if (!isFinite(bounds.min.x) || !isFinite(bounds.max.x) || bounds.isEmpty()) {
                    bounds = new THREE.Box3(new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, 1, 1));
                }
                const size = bounds.getSize(new THREE.Vector3());
                const padding = size.length() * 0.1;
                bounds.expandByScalar(padding > 0.1 ? padding : 0.5);
                this.app.updateSlicingSliderRange(bounds);
                const isLightTheme = document.body.classList.contains('light-theme');
                const gridColor = isLightTheme ? 0xCBD5E1 : 0x374151;
                const textColor = isLightTheme ? '#0f172a' : '#f1f5f9';
                const sizeVec = bounds.getSize(new THREE.Vector3());
                const center = bounds.getCenter(new THREE.Vector3());
                const grid = new THREE.GridHelper(30, 30, gridColor, gridColor);
                grid.rotation.x = Math.PI / 2;
                grid.scale.set(sizeVec.x / 30, sizeVec.y / 30, 1);
                grid.position.set(0,0,0);
                grid.material.opacity = 0.50;         
                grid.material.transparent = true;
                this.axesGroup.add(grid);
                const axisConfig = [{ name: 'X', color: 0xaa4444, dir: new THREE.Vector3(1, 0, 0) }, { name: 'Y', color: 0x44aa44, dir: new THREE.Vector3(0, 1, 0) }, { name: 'Z', color: 0x4444aa, dir: new THREE.Vector3(0, 0, 1) }];
                axisConfig.forEach(({ name, color, dir }) => {
                    const axisName = name.toLowerCase();
                    const material = new THREE.LineBasicMaterial({ color: color });
                    const lineStart = dir.clone().multiplyScalar(bounds.min[axisName]);
                    const lineEnd = dir.clone().multiplyScalar(bounds.max[axisName]);
                    const geometry = new THREE.BufferGeometry().setFromPoints([lineStart, lineEnd]);
                    const line = new THREE.Line(geometry, material);
                    this.axesGroup.add(line);
                    const labelPos = lineEnd.clone().multiplyScalar(1.1);
                    this.axesGroup.add(this.createLabel(name, labelPos, textColor, 48));
                    const ticks = this.calculateNiceTicks(bounds.min[axisName], bounds.max[axisName]);
                    ticks.forEach(tickVal => {
                        if (Math.abs(tickVal) < 1e-9) return;
                        const tickPos = dir.clone().multiplyScalar(tickVal);
                        const tickSize = size.length() * 0.01;
                        const orthoDir = name === 'Z' ? new THREE.Vector3(1, 0, 0) : new THREE.Vector3(0, 0, 1);
                        const tickGeom = new THREE.BufferGeometry().setFromPoints([tickPos.clone().sub(orthoDir.clone().multiplyScalar(tickSize)), tickPos.clone().add(orthoDir.clone().multiplyScalar(tickSize))]);
                        const tickLine = new THREE.LineSegments(tickGeom, material);
                        this.axesGroup.add(tickLine);
                        const labelOffset = orthoDir.clone().multiplyScalar(tickSize * 2.5);
                        const numLabel = this.createLabel(tickVal.toString(), tickPos.clone().add(labelOffset), textColor, 32);
                        this.axesGroup.add(numLabel);
                    });
                });
                this.renderDirty = true;
            }
        
            createColormapTexture(colormapName) {
                const gradient = this.app.colormaps[colormapName]?.gradient;
                if (!gradient) { return this.createColormapTexture('Viridis'); }
                const colors = gradient.match(/#[0-9a-f]{6}/ig).map(hex => new THREE.Color(hex));
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 1;
                const context = canvas.getContext('2d');
                const grad = context.createLinearGradient(0, 0, 256, 0);
                colors.forEach((color, index) => {
                    grad.addColorStop(index / (colors.length - 1), color.getStyle());
                });
                context.fillStyle = grad;
                context.fillRect(0, 0, 256, 1);
                return new THREE.CanvasTexture(canvas);
            }
        
            
            createSurfaceMesh(obj, isWireframe) {
                const { vertices, indices, values, zMin, zMax } = obj.lastData;
                if (!vertices || vertices.length === 0) return null;
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                geometry.setIndex(new THREE.BufferAttribute(indices, 1));
                geometry.computeVertexNormals();
                let material;
                if (obj.config.useShader) {
                    geometry.setAttribute('colorValue', new THREE.BufferAttribute(values, 1));
                    const texture = this.createColormapTexture(obj.colormap);
                    material = new THREE.ShaderMaterial({
                        uniforms: {
                            colormap: { value: texture },
                            zMin: { value: zMin },
                            zMax: { value: zMax },
                            opacity: { value: obj.config.opacity }
                        },
                        vertexShader: `
                            attribute float colorValue;
                            varying float vValue;
                            void main() {
                                vValue = colorValue;
                                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            }`,
                        fragmentShader: `
                            uniform sampler2D colormap;
                            uniform float zMin;
                            uniform float zMax;
                            uniform float opacity;
                            varying float vValue;
                            void main() {
                                if (isnan(vValue)) discard;
                                float normalizedValue = (vValue - zMin) / (zMax - zMin);
                                vec4 color = texture2D(colormap, vec2(normalizedValue, 0.5));
                                color.a *= opacity;
                                gl_FragColor = color;
                            }`,
                        wireframe: isWireframe,
                        side: THREE.DoubleSide,
                        transparent: true,
                        clipping: true
                    });
                } else {
                    const colors = [];
                    const gradientString = this.app.colormaps[obj.colormap].gradient;
                    const gradientColors = gradientString.match(/#[0-9a-f]{6}/ig).map(hex => new THREE.Color(hex));
                    const getGradientColor = (val) => {
                        let normalized = (zMax > zMin) ? (val - zMin) / (zMax - zMin) : 0;
                        normalized = Math.max(0, Math.min(1, normalized));
                        const idx = normalized * (gradientColors.length - 1);
                        const startIndex = Math.floor(idx);
                        const endIndex = Math.min(startIndex + 1, gradientColors.length - 1);
                        const alpha = idx - startIndex;
                        return new THREE.Color().copy(gradientColors[startIndex]).lerp(gradientColors[endIndex], alpha);
                    };
                    for (let i = 0; i < values.length; i++) {
                        const val = values[i];
                        if (!isFinite(val)) {
                            colors.push(0, 0, 0);
                        } else {
                            const color = getGradientColor(val);
                            colors.push(color.r, color.g, color.b);
                        }
                    }
                    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                    material = new THREE.MeshStandardMaterial({
                        vertexColors: true,
                        side: THREE.DoubleSide,
                        wireframe: isWireframe,
                        opacity: obj.config.opacity,
                        transparent: obj.config.opacity < 1.0,
                        clippingPlanes: [this.clipPlane]
                    });
                }
                return new THREE.Mesh(geometry, material);
            }

            clearPathVisualizers() {
                while (this.pathVisualizerGroup.children.length > 0) {
                   const pathObject = this.pathVisualizerGroup.children[0];
                   if (pathObject.geometry) pathObject.geometry.dispose();
                   if (pathObject.material) pathObject.material.dispose();
                   this.pathVisualizerGroup.remove(pathObject);
               }
           }
           
           updatePathVisualizer(objectId, waypoints) {
               let line = this.pathVisualizerGroup.getObjectByName(objectId);
               if (line) {
                   line.geometry.dispose();
                   this.pathVisualizerGroup.remove(line);
               }
           
               if (waypoints && waypoints.length > 1) {
                   const points = waypoints.map(wp => new THREE.Vector3(wp.x, wp.y, wp.z));
                   const geometry = new THREE.BufferGeometry().setFromPoints(points);
                   const material = new THREE.LineDashedMaterial({
                       color: 0xffffff,
                       linewidth: 1,
                       scale: 1,
                       dashSize: 0.5,
                       gapSize: 0.2,
                   });
                   line = new THREE.Line(geometry, material);
                   line.computeLineDistances();
                   line.name = objectId;
                   this.pathVisualizerGroup.add(line);
               }
           }
        
            createImplicitMesh(obj, isWireframe) {
                const { vertices, faces } = obj.lastData;
                if (!vertices || vertices.length === 0 || !faces || faces.length === 0) {
                    return null;
                }
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(vertices.length * 3);
                const values = new Float32Array(vertices.length);
                let calculatedMinZ = Infinity;
                let calculatedMaxZ = -Infinity;
                for (let i = 0; i < vertices.length; i++) {
                    const v = vertices[i];
                    if (!v || !isFinite(v.x) || !isFinite(v.y) || !isFinite(v.z)) continue;
                    positions[i * 3] = v.x;
                    positions[i * 3 + 1] = v.y;
                    positions[i * 3 + 2] = v.z;
                    values[i] = v.z;
                    if (v.z < calculatedMinZ) calculatedMinZ = v.z;
                    if (v.z > calculatedMaxZ) calculatedMaxZ = v.z;
                }
                const indices = new Uint32Array(faces);
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('colorValue', new THREE.BufferAttribute(values, 1));
                geometry.setIndex(new THREE.BufferAttribute(indices, 1));
                geometry.computeVertexNormals();
                const texture = this.createColormapTexture(obj.colormap);
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        colormap: { value: texture },
                        zMin: { value: calculatedMinZ },
                        zMax: { value: calculatedMaxZ },
                        opacity: { value: obj.config?.opacity ?? 1.0 }
                    },
                    vertexShader: `
                        attribute float colorValue;
                        varying float vValue;
                        void main() {
                            vValue = colorValue;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D colormap;
                        uniform float zMin;
                        uniform float zMax;
                        uniform float opacity;
                        varying float vValue;
                        void main() {
                            if (isnan(vValue)) discard;
                            float normalizedValue = (vValue - zMin) / (zMax - zMin);
                            vec4 color = texture2D(colormap, vec2(normalizedValue, 0.5));
                            color.a *= opacity;
                            gl_FragColor = color;
                        }
                    `,
                    wireframe: isWireframe,
                    side: THREE.DoubleSide,
                    transparent: true,
                    clipping: true
                });
                return new THREE.Mesh(geometry, material);
            }
            
            
            createCurveMesh(obj) {
                const { vertices, values } = obj.lastData;
                if (!vertices || vertices.length === 0) return null;
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                const vertexColors = [];
                const tMin = obj.config.tMin;
                const tMax = obj.config.tMax;
                const gradientString = this.app.colormaps[obj.colormap].gradient;
                const gradientColors = gradientString.match(/#[0-9a-f]{6}/ig).map(hex => new THREE.Color(hex));
                const getGradientColor = (t) => {
                    const idx = t * (gradientColors.length - 1);
                    const startIndex = Math.floor(idx);
                    const endIndex = Math.min(startIndex + 1, gradientColors.length - 1);
                    const alpha = idx - startIndex;
                    return new THREE.Color().copy(gradientColors[startIndex]).lerp(gradientColors[endIndex], alpha);
                };
                for (let i = 0; i < values.length; i++) {
                    const tNormalized = (values[i] - tMin) / (tMax - tMin);
                    const color = getGradientColor(tNormalized);
                    vertexColors.push(color.r, color.g, color.b);
                }
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(vertexColors, 3));
                const material = new THREE.LineBasicMaterial({
                    vertexColors: true,
                    linewidth: 3,
                    transparent: true,
                    opacity: obj.config?.opacity ?? 1.0,
                    clippingPlanes: [this.clipPlane],
                    clipIntersection: false
                });
                return new THREE.Line(geometry, material);
            }
            
            
            createVectorMesh(obj) {
                const { vectors, minMag, maxMag } = obj.lastData;
                if (!vectors || vectors.length === 0) return null;
                const shaftGeom = new THREE.CylinderGeometry(0.01, 0.01, 0.8, 8);
                shaftGeom.translate(0, 0.4, 0);
                const headGeom = new THREE.ConeGeometry(0.03, 0.2, 6);
                headGeom.translate(0, 0.9, 0);
                const arrowGeom = THREE.BufferGeometryUtils.mergeBufferGeometries([shaftGeom, headGeom]);
                const arrowMat = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: obj.config?.opacity ?? 1.0,
                    clippingPlanes: [this.clipPlane],
                    clipIntersection: false
                });
                const instancedMesh = new THREE.InstancedMesh(arrowGeom, arrowMat, vectors.length);
                const dummy = new THREE.Object3D();
                const color = new THREE.Color();
                vectors.forEach((vec, i) => {
                    dummy.position.set(vec.origin.x, vec.origin.y, vec.origin.z);
                    const dir = new THREE.Vector3(vec.components.x, vec.components.y, vec.components.z).normalize();
                    dummy.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir);
                    const scale = obj.config.scale * (vec.mag / maxMag);
                    dummy.scale.set(1, scale, 1);
                    dummy.updateMatrix();
                    instancedMesh.setMatrixAt(i, dummy.matrix);
                    const normalizedMag = (maxMag > minMag) ? (vec.mag - minMag) / (maxMag - minMag) : 0;
                    color.setHSL(0.7 * (1 - normalizedMag), 1.0, 0.5);
                    instancedMesh.setColorAt(i, color);
                });
                return instancedMesh;
            }
        
            createSingleVectorMesh(obj) {
                const c = obj.config;
                const origin = new THREE.Vector3(c.ox, c.oy, c.oz);
                const dir = new THREE.Vector3(c.vx, c.vy, c.vz);
                const length = dir.length();
                if (length < 1e-6) return null;
                const visualScale = c.visualScale || 1.0;
                const headLength = Math.max(length * 0.1, 0.5) * visualScale;
                const headWidth = Math.max(length * 0.05, 0.25) * visualScale;
                const arrowHelper = new THREE.ArrowHelper(dir.normalize(), origin, length, c.color, headLength, headWidth);
                const opacity = obj.config?.opacity ?? 1.0;
                arrowHelper.line.material.transparent = true;
                arrowHelper.line.material.opacity = opacity;
                arrowHelper.line.material.clippingPlanes = [this.clipPlane];
                arrowHelper.line.material.clipIntersection = false;
                arrowHelper.cone.material.transparent = true;
                arrowHelper.cone.material.opacity = opacity;
                arrowHelper.cone.material.clippingPlanes = [this.clipPlane];
                arrowHelper.cone.material.clipIntersection = false;
                return arrowHelper;
            }
        
            updateClippingPlane(enabled, axis, position) {
                this.renderer.localClippingEnabled = enabled;
                let normal;
                if (axis === 'x') normal = new THREE.Vector3(-1, 0, 0);
                else if (axis === 'y') normal = new THREE.Vector3(0, -1, 0);
                else normal = new THREE.Vector3(0, 0, -1);
                this.clipPlane.normal = normal;
                this.clipPlane.constant = position;
                this.renderDirty = true;
            }
        
            updateTheme() {
                const isLightTheme = document.body.classList.contains('light-theme');
                if (isLightTheme) {
                    const canvasBg = getComputedStyle(document.body).getPropertyValue('--canvas-bg').trim();
                    let color;
                    if (canvasBg.startsWith('#')) {
                        color = new THREE.Color(canvasBg);
                    } else if (canvasBg.startsWith('rgb')) {
                        const rgb = canvasBg.match(/\d+/g).map(Number);
                        color = new THREE.Color(rgb[0] / 255, rgb[1] / 255, rgb[2] / 255);
                    } else {
                        color = new THREE.Color(0xf8fafc);
                    }
                    this.renderer.setClearColor(color, 1);
                } else {
                    this.renderer.setClearColor(0x111827, 1);
                }
                this.updateHUDText(this.hudSprite.material.map.image.getContext('2d').measureText(this.hudSprite.material.map.image.getContext('2d').font).actualBoundingBoxRight > 0 ? this.hudSprite.material.map.image.getContext('2d').measureText(this.hudSprite.material.map.image.getContext('2d').font).actualBoundingBoxRight > 0 ? this.hudSprite.material.map.image.getContext('2d').measureText(this.hudSprite.material.map.image.getContext('2d').font).actualBoundingBoxRight > 0 ? this.hudSprite.material.map.image.getContext('2d').measureText(this.hudSprite.material.map.image.getContext('2d').font).actualBoundingBoxRight > 0 ? 'Hover for coordinates...' : this.hudSprite.material.map.image.getContext('2d').measureText(this.hudSprite.material.map.image.getContext('2d').font).actualBoundingBoxRight > 0 ? 'Hover for coordinates...' : this.hudSprite.material.map.image.getContext('2d').measureText(this.hudSprite.material.map.image.getContext('2d').font).actualBoundingBoxRight > 0 ? 'Hover for coordinates...' : 'Hover for coordinates...' : 'Hover for coordinates...' : 'Hover for coordinates...' : 'Hover for coordinates...');
                this.updateAxesAndGrid();
            }
        
            toggleGrid(visible) {
                this.axesGroup.visible = visible;
                this.renderDirty = true;
            }
        
            exportPNG() {
                this.renderer.render(this.scene, this.camera);
                this.renderer.render(this.hudScene, this.hudCamera);
                const dataURL = this.renderer.domElement.toDataURL('image/png');
                const a = document.createElement('a');
                a.href = dataURL;
                a.download = 'plotter-pro-export.png';
                a.click();
            }
        
            setCameraView(view) {
                this.controls.reset();
                this.app.stopAllAnimations();
                this.updateAxesAndGrid();
                let bounds = this.axesGroup.children.length > 0 ? new THREE.Box3().setFromObject(this.axesGroup) : new THREE.Box3(new THREE.Vector3(-10, -10, -10), new THREE.Vector3(10, 10, 10));
                const center = bounds.getCenter(new THREE.Vector3());
                const size = bounds.getSize(new THREE.Vector3()).length();
                const camPos = size > 0.1 ? size * 1.5 : 20;
                this.camera.position.set(center.x + camPos, center.y + camPos, center.z + camPos);
                this.camera.up.set(0, 0, 1);
                switch (view) {
                    case 'top': this.camera.position.set(center.x, center.y, center.z + camPos); break;
                    case 'front': this.camera.position.set(center.x, center.y - camPos, center.z); break;
                    case 'side': this.camera.position.set(center.x + camPos, center.y, center.z); break;
                    case 'reset':
                    default: this.camera.position.set(center.x - camPos * 0.7, center.y - camPos * 0.7, center.z + camPos * 0.7); break;
                }
                this.camera.lookAt(center);
                this.renderDirty = true;
            }
        }
        
        class AppController {
            constructor() {
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', () => this.init());
                } else {
                    this.init();
                }
                this.currentTutorialStep = 0;
                this.tutorialIsActive = false;
                this.tutorialSteps = [
                    {
                        title: "Welcome to 6AxisAnimation!",
                        text: "Let's take a quick tour of the main features to get you started."
                    },
                    {
                        selector: '.mode-tab[data-mode="playground"]',
                        title: "The Playground",
                        text: "You are in Playground mode, a sandbox for creating and combining multiple 3D objects. Other modes focus on a single plot."
                    },
                    {
                        selector: '#add-object-btn',
                        title: "Add an Object",
                        text: "This is where you begin. Click here to add mathematical objects like surfaces, curves, and vectors to your scene."
                    },
                    {
                        selector: '.playground-object',
                        title: "The Object Card",
                        text: "Each object you add gets its own card. Here you can define its mathematical formula and configure its appearance."
                    },
                    {
                        selector: '.animation-tray-wrapper',
                        title: "The Animation Panel",
                        text: "This is the control center for all animations. When you have an animatable object, its controller will appear here. You can animate an object's shape (V-Mode), its movement (P-Mode), or use a simple physics simulation."
                    },
                    {
                        selector: '#plot-container',
                        title: "The 3D Viewport",
                        text: "Interact with your creation! Click and drag to rotate, scroll to zoom, and right-click and drag to pan the camera."
                    },
                    {
                        title: "You're All Set!",
                        text: "That's everything you need to know to get started. Enjoy creating!"
                    }
                ];
            }
        
            init() {
                this.plotter = new ThreeJSPlotter(this);
                this.currentMode = 'playground';
                this.plotQueue = [];
                this.isBatchUpdating = false;
                this.focusedObjectId = null;
                this.isPlotting = new Set();
                this.mathFields = {};
                this.activeMathFieldId = null;
                this.mathFieldHistory = {};
                this.mathFieldHistoryPointer = {};
                this.mathFieldChangeTimeout = null;
                this.playgroundObjects = [];
                this.modeStates = { playground: [], surface: [], parametric: [], curve: [] };
                
                this.colormaps = {
                    Plasma: { name: 'Plasma', gradient: 'linear-gradient(90deg, #0d0887, #a41e9a, #fca636, #f0f921)' },
                    Viridis: { name: 'Viridis', gradient: 'linear-gradient(90deg, #440154, #21918c, #fde725)' },
                    Jet: { name: 'Jet', gradient: 'linear-gradient(90deg, #000080, #00FFFF, #FFFF00, #FF0000, #800000)' },
                    Hot: { name: 'Hot', gradient: 'linear-gradient(90deg, #000000, #FF0000, #FFFF00, #FFFFFF)' },
                    Cool: { name: 'Cool', gradient: 'linear-gradient(90deg, #00ffff, #ff00ff)' },
                    Greys: { name: 'Greys', gradient: 'linear-gradient(90deg, #000000, #FFFFFF)' },
                    Reds: { name: 'Reds', gradient: 'linear-gradient(90deg, #fff5f0, #fee0d2, #fcbba1, #fc9272, #fb6a4a, #ef3b2c, #cb181d, #99000d)' },
                    Blues: { name: 'Blues', gradient: 'linear-gradient(90deg, #f7fbff, #deebf7, #c6dbef, #9ecae1, #6baed6, #4292c6, #2171b5, #084594)' },
                    Greens: { name: 'Greens', gradient: 'linear-gradient(90deg, #f7fcf5, #e5f5e0, #c7e9c0, #a1d99b, #74c476, #41ab5d, #238b45, #005a32)' },
                    Purples: { name: 'Purples', gradient: 'linear-gradient(90deg, #fcfbfd, #efedf5, #dadaeb, #bcbddc, #9e9ac8, #807dba, #6a51a3, #4a1486)' },
                    Oranges: { name: 'Oranges', gradient: 'linear-gradient(90deg, #fff5eb, #fee6ce, #fdd0a2, #fdae6b, #fd8d3c, #f16913, #d94801, #8c2d04)' },
                    Browns: { name: 'Browns', gradient: 'linear-gradient(90deg, #f6e8c3, #dfc27d, #bf812d, #8c510a, #543005)' },
                    Yellows: { name: 'Yellows', gradient: 'linear-gradient(90deg, #ffffd4, #fee391, #fec44f, #fe9929, #d95f0e, #993404)' },
                    Cividis: { name: 'Cividis', gradient: 'linear-gradient(90deg, #00224e, #537e86, #f9e671)' },
                    Electric: { name: 'Electric', gradient: 'linear-gradient(90deg, #000000, #31052e, #890976, #e336a3, #f8c8dd, #ffffff)' },
                    Blackbody: { name: 'Blackbody', gradient: 'linear-gradient(90deg, #000000, #b22222, #ffcc00, #ffffff)' }
                };
            
                this.Easing = {
                    linear: t => t,
                    easeInQuad: t => t*t,
                    easeOutQuad: t => t*(2-t),
                    easeInOutQuad: t => t < 0.5 ? 2*t*t : -1 + (4-2*t)*t,
                };
            
                this.globalAnimationFrameId = null;
                this.globalLastTimestamp = 0;
                this.animationPerformancePresets = {
                    smooth:   { name: 'Smooth',   qualityFactor: 0.3,  throttle: 100  },
                    balanced: { name: 'Balanced', qualityFactor: 0.5,  throttle: 200 },
                    detailed: { name: 'Detailed', qualityFactor: 0.75, throttle: 300 },
                    ultra:    { name: 'Ultra',    qualityFactor: 1.0,  throttle: 400 }
                };
                this.currentAnimationPerformance = 'smooth';
                
                this.initializeElements();
                this.initializeCalculator();
                this.initializePresets();
                this.initializeWorker();
                this.setupEventListeners();
                this.setupIconToggles();
                this.initAccordions();
                this.expressionCache = {};
                this.FIXED_TIMESTEP = 1 / 60;
                this.accumulator = 0;
               
                this.renderAllPlotsDebounced = this.debounce(() => this.plotter.renderAllPlots(), 50);
            
                // --- START: New, Smarter Preloading Logic ---
                const loadedFromUrl = this.loadStateFromURL();
            
                if (loadedFromUrl) {
                    // State is loaded from a shared URL, do nothing else.
                } else if (!localStorage.getItem('plotterProTutorialCompleted')) {
                    // This is a user's VERY FIRST visit.
                    this.switchMode('playground', true);
                    const atomPreset = this.playgroundPresets['Atom'];
                    if (atomPreset) {
                        this.loadPlaygroundPreset(atomPreset);
                    }
                    setTimeout(() => this.startTutorial(), 500);
                } else {
                    // This is a RETURNING user.
                    const loadedFromStorage = this.loadLastState();
                    if (!loadedFromStorage) {
                        // If they have no saved state, give them a clean slate.
                        this.switchMode('playground', true);
                    }
                }
                // --- END: New Preloading Logic ---
            
                this.renderGlobalAnimationTray();
            }
        
            initializeElements() {
                this.modeTabs = document.querySelectorAll('.mode-tab');
                this.singleModeControls = document.getElementById('single-mode-controls');
                this.playgroundControls = document.getElementById('playground-controls');
                this.playgroundObjectsContainer = document.getElementById('playground-objects-container');
                this.loadingOverlay = document.getElementById('loading-overlay');
                this.animationTray = document.getElementById('global-animation-tray');
                this.coordsStatus = document.getElementById('coords-status');
                this.coordsStatusText = document.getElementById('coords-status-text');
                this.toastEl = document.getElementById('toast');
                this.appGrid = document.querySelector('.app-grid');
                this.presetsAccordion = document.getElementById('presets-accordion');
                this.presetsTitle = document.getElementById('presets-title');
                this.globalPlayPauseBtn = document.getElementById('global-play-pause-btn');
                this.globalPlayIcon = document.getElementById('global-play-icon');
                this.globalPauseIcon = document.getElementById('global-pause-icon');
                this.slicingEnabledToggle = document.getElementById('slicing-enabled-toggle');
                this.debouncedAutoSave = this.debounce(() => this.autoSaveState(), 1000);
            }
            
                
                this.sliceAxisCheckboxes = document.querySelectorAll('.slicing-axis-toggle input[type="checkbox"]');
                this.slicePositionSliders = {
                    x: document.getElementById('slice-position-slider-x'),
                    y: document.getElementById('slice-position-slider-y'),
                    z: document.getElementById('slice-position-slider-z')
                };
                this.slicePositionValues = {
                    x: document.getElementById('slice-position-value-x'),
                    y: document.getElementById('slice-position-value-y'),
                    z: document.getElementById('slice-position-value-z')
                };
                
            }

            renderPlaygroundUI() {
                if (this.currentMode === 'playground') {
                    
                    const fragment = document.createDocumentFragment();
            
                    if (this.playgroundObjects.length === 0) {
                        const emptyState = document.createElement('div');
                        emptyState.className = "text-center text-text-muted p-8 border-2 border-dashed border-border-color rounded-lg";
                        emptyState.innerHTML = `<svg ...>...</svg><h3>Empty Playground</h3><p>Click "Add Object" to start plotting.</p>`; 
                        fragment.appendChild(emptyState);
                    } else {
                        this.playgroundObjects.forEach(obj => {
                            const div = document.createElement('div');
                            div.className = 'playground-object';
                            if(this.focusedObjectId === obj.id) div.classList.add('focused');
                            div.dataset.objectId = obj.id;
                            div.innerHTML = this.getPlaygroundObjectHTML(obj);
                            
                            this.initializeMathFields(div);
                            this.setupPlaygroundObjectListeners(div, obj);
                            fragment.appendChild(div);
                        });
                    }
                    
                    
                    this.playgroundObjectsContainer.innerHTML = '';
                    this.playgroundObjectsContainer.appendChild(fragment);
            
                } else {
                    
                    const container = this.singleModeControls.querySelector(`.${this.currentMode}-controls`);
                    if (!container) return;
                    container.innerHTML = '';
                    const obj = this.playgroundObjects[0];
                    if (obj) {
                        const div = document.createElement('div');
                        div.dataset.objectId = obj.id;
                        div.innerHTML = this.getPlaygroundObjectHTML(obj);
                        container.appendChild(div);
                        this.initializeMathFields(div);
                    }
                    this.renderAppearanceSettings();
                }
            }


            showInfoModal() {
                this.infoModalCurrentSlide = 1;
                document.getElementById('info-modal-overlay')?.classList.remove('hidden');
                this.updateInfoModalSlide();
            }
            
            hideInfoModal() {
                document.getElementById('info-modal-overlay')?.classList.add('hidden');
            }
            
            updateInfoModalSlide() {
                const slides = document.querySelectorAll('.info-slide');
                this.infoModalTotalSlides = slides.length;
            
                slides.forEach((slide, index) => {
                    slide.classList.toggle('active', (index + 1) === this.infoModalCurrentSlide);
                });
            
                document.getElementById('info-modal-counter').textContent = `${this.infoModalCurrentSlide} / ${this.infoModalTotalSlides}`;
                document.getElementById('info-modal-prev').style.visibility = (this.infoModalCurrentSlide === 1) ? 'hidden' : 'visible';
            
                const nextButton = document.getElementById('info-modal-next');
                if (this.infoModalCurrentSlide === this.infoModalTotalSlides) {
                    nextButton.textContent = 'Got it!';
                } else {
                    nextButton.textContent = 'Next';
                }
            }


            initAccordions() {
                document.querySelectorAll('.left-panel .accordion').forEach((acc, index) => {
                    const header = acc.querySelector('.accordion-header');
                    const content = acc.querySelector('.accordion-content');
                    if (!header || !content) return;
                    header.addEventListener('click', () => {
                        const isOpen = header.classList.toggle('open');
                        content.classList.toggle('open');
                        content.style.maxHeight = isOpen ? content.scrollHeight + 32 + "px" : '0px';
                    });
                });
            }

            initializeWorker() {
                const workerScript = document.getElementById('worker-script').textContent;
                const workerBlob = new Blob([workerScript], { type: 'application/javascript' });
                this.worker = new Worker(URL.createObjectURL(workerBlob));
                this.worker.onmessage = (e) => {
                    const { id } = e.data;
                    this.isPlotting.delete(id);

                    const obj = this.getPlaygroundObject(id);
                    if (!obj) return;

                    const card = document.querySelector(`[data-object-id="${id}"]`);
                    card?.classList.remove('is-plotting');
                    
                    if (e.data.status === 'error') {
                        this.showError(e.data.message, id);
                        this.stopAnimation(id);
                        return;
                    }

                    if (e.data.status === 'success') {
                        this.hideError(id);
                        obj.lastData = e.data.data;
                        this.plotter.updateSinglePlot(obj, document.getElementById('wireframe-toggle').checked);
                        this.applyAdvancedTransforms(obj);
                        this.processNextInQueue();
                    }
                };
            }

            initializeMathFields(container) {
                const MQ = MathQuill.getInterface(2);

                container.querySelectorAll('.math-input-field').forEach(span => {
                    if (span.classList.contains('mq-initialized')) return;
                    span.classList.add('mq-initialized');

                    const id = span.id;
                    const objectId = span.closest('[data-object-id]').dataset.objectId;
                    const debouncedPlot = this.debounce(() => this.plot(objectId), 400);

                    if (!this.mathFieldHistory[id]) {
                        this.mathFieldHistory[id] = [];
                        this.mathFieldHistoryPointer[id] = -1;
                    }

                    const mathField = MQ.MathField(span, {
                        spaceBehavesLikeTab: true,
                        handlers: {
                            edit: (mathField) => {
                                this.activeMathFieldId = id;
                                this.hideError(objectId);

                                const currentLatex = mathField.latex();
                                const history = this.mathFieldHistory[id];
                                let pointer = this.mathFieldHistoryPointer[id];

                                if (this.mathFieldChangeTimeout) {
                                    clearTimeout(this.mathFieldChangeTimeout);
                                }

                                this.mathFieldChangeTimeout = setTimeout(() => {
                                    if (history.length === 0 || history[pointer] !== currentLatex) {
                                        if (pointer < history.length - 1) {
                                            history.splice(pointer + 1);
                                        }
                                        history.push(currentLatex);
                                        this.mathFieldHistoryPointer[id] = history.length - 1;

                                        if (history.length > 100) {
                                            history.shift();
                                            this.mathFieldHistoryPointer[id]--;
                                        }
                                    }
                                }, 300);

                                debouncedPlot();
                            },
                            enter: () => this.plot(objectId)
                        }
                    });

                    if (this.mathFieldHistory[id].length === 0) {
                        this.mathFieldHistory[id].push('');
                        this.mathFieldHistoryPointer[id] = 0;
                    }

                    $(mathField.el()).on('focus', () => {
                        this.activeMathFieldId = id;
                    });

                    this.mathFields[id] = mathField;
                });
            }

            autoSaveState() {
                try {
                    const settings = this.collectSettings();
                    const jsonString = JSON.stringify(settings);
                    localStorage.setItem('plotterProLastState', jsonString);
                } catch (e) {
                    console.error("Auto-save failed:", e);
                }
            }
            
            loadLastState() {
                const savedState = localStorage.getItem('plotterProLastState');
                if (savedState) {
                    try {
                        const settings = JSON.parse(savedState);
                        this.applySettings(settings);
                        return true; // Return true on successful load
                    } catch (e) {
                        console.error("Failed to load last state:", e);
                        return false;
                    }
                }
                return false;
            }

            setupIconToggles() {
                document.querySelectorAll('.icon-toggle-btn').forEach(btn => {
                    const checkbox = btn.querySelector('input[type="checkbox"]');
                    if (!checkbox) return;
                    const clickHandler = () => btn.classList.toggle('active', checkbox.checked);
                    btn.addEventListener('click', clickHandler);
                    clickHandler();
                });
            }

            processNextInQueue() {
                if (this.plotQueue.length === 0) return; 
            
                
                const nextId = this.plotQueue.shift(); 
                const obj = this.getPlaygroundObject(nextId);
            
                if (obj) {
                    
                    const card = document.querySelector(`[data-object-id="${nextId}"]`);
                    card?.classList.add('is-plotting');
                    this.plot(nextId, {}, false, true); 
                }
            }

            handleUndoRedo(e, isRedo = false) {
                if (!this.activeMathFieldId || !this.mathFields[this.activeMathFieldId]) return;

                const history = this.mathFieldHistory[this.activeMathFieldId] || [];
                let pointer = this.mathFieldHistoryPointer[this.activeMathFieldId] || 0;
                const mathField = this.mathFields[this.activeMathFieldId];

                if (isRedo) {
                    if (pointer < history.length - 1) {
                        pointer++;
                        this.mathFieldHistoryPointer[this.activeMathFieldId] = pointer;
                        mathField.latex(history[pointer]);
                    }
                } else {
                    if (pointer > 0) {
                        pointer--;
                        this.mathFieldHistoryPointer[this.activeMathFieldId] = pointer;
                        mathField.latex(history[pointer]);
                    }
                }

                e.preventDefault();
                e.stopPropagation();

                const objectId = $(mathField.el()).closest('[data-object-id]').data('objectId');
                if (objectId) this.plot(objectId);
            }
 
            setupEventListeners() {
                const debouncedPlot = this.debounce((id) => this.plot(id), 400);

                document.addEventListener('keydown', (e) => {
                    if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) { this.handleUndoRedo(e, false); } 
                    else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.shiftKey && e.key === 'Z'))) { this.handleUndoRedo(e, true); }
                });

                this.modeTabs.forEach(tab => tab.addEventListener('click', () => this.switchMode(tab.dataset.mode)));
                
                this.globalPlayPauseBtn.addEventListener('click', () => this.toggleAllAnimations());
                document.getElementById('global-reset-btn').addEventListener('click', () => this.resetAllAnimationsAndInputs());

                const inputHandler = (e) => {
                    const target = e.target;
                    const objectContainer = target.closest('[data-object-id]');
                    if (!objectContainer) return;

                    const objectId = objectContainer.dataset.objectId;
                    const obj = this.getPlaygroundObject(objectId);
                    if (!obj) return;

                    const configKey = target.dataset.config;
                    if (configKey) {
                         const value = target.type === 'checkbox' ? target.checked : (target.type === 'number' || target.type === 'range' ? parseFloat(target.value) : (target.type === 'color' ? target.value : target.value));
                         obj.config[configKey] = value;
                         const valueSpan = target.parentElement.querySelector('.range-value-display');
                         if (valueSpan) valueSpan.textContent = parseFloat(target.value).toFixed(target.step && target.step.includes('.') ? 2 : 0);
                         debouncedPlot(objectId);
                    }
                };
                
                document.querySelector('.left-panel').addEventListener('input', inputHandler);

                document.getElementById('wireframe-toggle').addEventListener('change', () => this.plotter.renderAllPlots());
                document.getElementById('grid-toggle').addEventListener('change', (e) => this.plotter.toggleGrid(e.target.checked));
                document.getElementById('export-png').addEventListener('click', () => this.plotter.exportPNG());
                document.getElementById('export-stl').addEventListener('click', () => this.exportSTL());
                document.getElementById('export-gltf').addEventListener('click', () => this.exportGLTF());
                document.getElementById('save-settings').addEventListener('click', () => this.saveSettings());
                document.getElementById('load-settings').addEventListener('change', (e) => this.loadSettings(e));
                document.getElementById('share-btn').addEventListener('click', () => this.shareState());

                
                const debouncedImplicitReplot = this.debounce(() => {
                    this.playgroundObjects.forEach(obj => {
                        if (obj.type === 'implicit' && obj.visible) {
                            this.plot(obj.id);
                        }
                    });
                }, 250);

                const handleSliceControlChange = () => {
                    const enabled = this.slicingEnabledToggle.checked;
                    const activeCheckboxes = Array.from(this.sliceAxisCheckboxes).filter(cb => cb.checked);

                    
                    
                    if (enabled && activeCheckboxes.length > 0) {
                        const primaryAxis = activeCheckboxes[0].value;
                        const position = parseFloat(this.slicePositionSliders[primaryAxis].value);
                        
                        this.plotter.updateClippingPlane(true, primaryAxis, position);
                    } else {
                        this.plotter.updateClippingPlane(false, 'x', 0);
                    }

                    
                    this.sliceAxisCheckboxes.forEach(checkbox => {
                        const label = checkbox.nextElementSibling;
                        if (label) {
                            label.classList.toggle('bg-primary', checkbox.checked);
                            label.classList.toggle('text-white', checkbox.checked);
                        }
                    });
                    
                    Object.keys(this.slicePositionSliders).forEach(axis => {
                        const slider = this.slicePositionSliders[axis];
                        const valueEl = this.slicePositionValues[axis];
                        if(slider && valueEl) {
                            valueEl.textContent = parseFloat(slider.value).toFixed(2);
                        }
                    });

                    
                    if (enabled) {
                        debouncedImplicitReplot();
                    }
                };

                this.slicingEnabledToggle.addEventListener('change', handleSliceControlChange);
                this.sliceAxisCheckboxes.forEach(cb => cb.addEventListener('change', handleSliceControlChange));
                Object.values(this.slicePositionSliders).forEach(slider => {
                    if (slider) slider.addEventListener('input', handleSliceControlChange);
                });

                
                handleSliceControlChange();
                

                ['reset', 'top', 'front', 'side'].forEach(id => {
                    const btn = document.getElementById(`cam-${id}`);
                    if (btn) btn.addEventListener('click', () => this.plotter.setCameraView(id));
                });

                const addObjectBtn = document.getElementById('add-object-btn');
                const addObjectMenu = document.getElementById('add-object-menu');
                if (addObjectBtn && addObjectMenu) {
                    addObjectBtn.addEventListener('click', (e) => { e.stopPropagation(); addObjectMenu.classList.toggle('show'); });
                    addObjectMenu.addEventListener('click', (e) => {
                        if (e.target.matches('.dropdown-item')) {
                            this.addPlaygroundObject(e.target.dataset.type);
                            addObjectMenu.classList.remove('show');
                        }
                    });
                }
                document.body.addEventListener('click', (e) => { if (addObjectMenu && !e.target.closest('#add-object-menu')) addObjectMenu.classList.remove('show') });

                document.getElementById('theme-toggle').addEventListener('click', () => { document.body.classList.toggle('light-theme'); this.plotter.updateTheme(); });
                document.getElementById('zen-mode-toggle').addEventListener('click', () => { this.appGrid.classList.toggle('zen-mode'); setTimeout(() => this.plotter.onResize(), 310); });
                document.getElementById('exit-zen-mode').addEventListener('click', () => { this.appGrid.classList.remove('zen-mode'); setTimeout(() => this.plotter.onResize(), 310); });
                document.getElementById('exit-fullscreen-mode').addEventListener('click', () => { this.appGrid.classList.remove('fullscreen-zen-mode'); setTimeout(() => this.plotter.onResize(), 310); });

                document.getElementById('fit-view-btn').addEventListener('click', () => this.fitViewToObjects());
                document.getElementById('info-btn')?.addEventListener('click', () => this.showInfoModal());
                document.getElementById('info-modal-close-btn')?.addEventListener('click', () => this.hideInfoModal());
                document.getElementById('global-select-all-btn')?.addEventListener('click', () => this.toggleAllOverrides());
                document.getElementById('info-modal-overlay')?.addEventListener('click', (e) => {
                    if (e.target.id === 'info-modal-overlay') {
                        this.hideInfoModal();
                    }
                });
                const leftPanel = document.querySelector('.left-panel');
                leftPanel.addEventListener('click', (e) => {
                    const calcTrigger = e.target.closest('.calc-trigger-btn');
                    if (calcTrigger) {
                        this.openCalculator(calcTrigger.dataset.fieldId, calcTrigger);
                        return;
                    }

                    const actionBtn = e.target.closest('.math-input-action-btn');
                    if(actionBtn) {
                        const fieldId = actionBtn.dataset.fieldId;
                        const mathField = this.mathFields[fieldId];
                        if(!mathField) return;
                        if(actionBtn.dataset.action === 'copy-latex') {
                            this.copyToClipboard(mathField.latex(), 'LaTeX copied!');
                        } else if (actionBtn.dataset.action === 'copy-mathjs') {
                            this.copyToClipboard(this.convertLatexToMathJs(mathField.latex()), 'MathJS expression copied!');
                        }
                    }
                });

                const forceFullscreenBtn = document.getElementById('force-fullscreen-btn');
                if (forceFullscreenBtn) {
                    forceFullscreenBtn.addEventListener('click', () => {
                        const docEl = document.documentElement;

                        // Standard and browser-prefixed functions for requesting fullscreen
                        const requestFullScreen = docEl.requestFullscreen || docEl.mozRequestFullScreen || docEl.webkitRequestFullscreen || docEl.msRequestFullscreen;
                        
                        // Standard and browser-prefixed functions for exiting fullscreen
                        const exitFullScreen = document.exitFullscreen || document.mozCancelFullScreen || document.webkitExitFullscreen || document.msExitFullscreen;

                        // Check if the page is currently in fullscreen mode
                        const isFullScreen = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement;

                        if (!isFullScreen) {
                            if (requestFullScreen) {
                                requestFullScreen.call(docEl);
                            }
                        } else {
                            if (exitFullScreen) {
                                exitFullScreen.call(document);
                            }
                        }
                    });
                }


                document.getElementById('info-modal-next')?.addEventListener('click', () => {
                    if (this.infoModalCurrentSlide < this.infoModalTotalSlides) {
                        this.infoModalCurrentSlide++;
                        this.updateInfoModalSlide();
                    } else {
                        this.hideInfoModal();
                    }
                });
                
                document.getElementById('info-modal-prev')?.addEventListener('click', () => {
                    if (this.infoModalCurrentSlide > 1) {
                        this.infoModalCurrentSlide--;
                        this.updateInfoModalSlide();
                    }
                });
                
                const resizeHandle = document.getElementById('resize-handle')
                const trayResizeHandle = document.getElementById('tray-resize-handle');
                let isResizing = false;
                let isTrayResizing = false;

                
                if (resizeHandle) {
                    resizeHandle.addEventListener('mousedown', () => { isResizing = true; document.body.classList.add('is-resizing'); });
                }

                
                if (trayResizeHandle) {
                    trayResizeHandle.addEventListener('mousedown', () => { isTrayResizing = true; document.body.classList.add('is-tray-resizing'); });
                }
                window.addEventListener('mousemove', (e) => {
                    if (isResizing) {
                        let newWidth = e.clientX;
                        newWidth = Math.max(280, Math.min(newWidth, 600)); 
                        document.documentElement.style.setProperty('--sidebar-width', `${newWidth}px`);
                    }
                    if (isTrayResizing) {
                        let newHeight = window.innerHeight - e.clientY;
                        newHeight = Math.max(120, Math.min(newHeight, 500));
                        document.documentElement.style.setProperty('--animation-tray-height', `${newHeight}px`);
                    }
                });
                window.addEventListener('mouseup', () => {
                    if (isResizing) { isResizing = false; document.body.classList.remove('is-resizing'); this.plotter.onResize(); }
                    if (isTrayResizing) { isTrayResizing = false; document.body.classList.remove('is-tray-resizing'); }
                });


                document.getElementById('tutorial-next-btn')?.addEventListener('click', () => {
                    if (this.currentTutorialStep < this.tutorialSteps.length - 1) {
                        this.currentTutorialStep++;
                        this.showTutorialStep(this.currentTutorialStep);
                    } else {
                        this.endTutorial();
                    }
                });
                
                document.getElementById('tutorial-prev-btn')?.addEventListener('click', () => {
                    if (this.currentTutorialStep > 0) {
                        this.currentTutorialStep--;
                        this.showTutorialStep(this.currentTutorialStep);
                    }
                });
            }

            updateSlicingSliderRange(bounds) {
                if (!this.slicePositionSliders || typeof this.slicePositionSliders !== 'object') {
                    return;
                }
                
                
                if (!this.slicePositionSliders.x && !this.slicePositionSliders.y && !this.slicePositionSliders.z) {
                    return;
                }
            
                Object.keys(this.slicePositionSliders).forEach(axis => {
                    const slider = this.slicePositionSliders[axis];
                    if (slider) {
                        
                        let min = bounds.min[axis];
                        let max = bounds.max[axis];
            
                        
                        if (!isFinite(min)) min = -10;
                        if (!isFinite(max)) max = 10;
                        
                        
                        if (max <= min) {
                            max = min + 1; 
                        }
            
                        const range = max - min;
                        let step = range / 200;
            
                        
                        if (!isFinite(step) || step <= 0) {
                            step = 0.1;
                        }
            
                        slider.min = min;
                        slider.max = max;
                        slider.step = step;
            
                        
                        if (parseFloat(slider.value) < min || parseFloat(slider.value) > max) {
                             slider.value = min + range / 2;
                             
                             slider.dispatchEvent(new Event('input', { bubbles: true }));
                        }
                    }
                });
            }
            

            debounce(func, wait) { let timeout; return (...args) => { clearTimeout(timeout); timeout = setTimeout(() => func.apply(this, args), wait); }; }
            
            initializePresets() {
                this.presets = {
                    // ... (all single-mode presets remain the same)
                    surface: [
                        { name: 'Pulsing Wave', equation: '5*\\sin(0.4*\\sqrt{x^2+y^2} - T)' },
                        { name: 'Gaussian Pulse', equation: '10*e^(-0.2*(x^2+y^2)/(sin(T*0.5)^2+0.1))' },
                        { name: 'Warping Saddle', equation: '0.1*(x^2 - y^2) * (2 + \\cos(T))' },
                        { name: 'Monkey Saddle', equation: '0.05*(x^3 - 3*x*y^2)' },
                        { name: 'Ripple', equation: '2*\\cos(x + T)*\\sin(y - T)' },
                        { name: 'Funnel', equation: '10/\\sqrt{x^2+y^2+1}' },
                        { name: 'Interfering Waves', equation: '3*\\sin(\\sqrt{(x-4)^2+y^2}-T) + 3*\\sin(\\sqrt{(x+4)^2+y^2}-T) + 2*\\sin(\\sqrt{x^2+(y-3)^2}-T*0.7)' },
                        { name: 'Parabolic Reflector', equation: '0.15*(x^2 + y^2) + \\sin(T)*\\cos(0.3*\\sqrt{x^2+y^2})' },
                        { name: 'Egg Carton', equation: '2*(sin(x) + cos(y)) + 0.5*\\sin(x*y*0.1 + T)' },
                        { name: 'Butterfly Surface', equation: '5*e^(-0.1*(x^2+y^2)) * (\\sin(x*0.5)*\\cos(y*0.5) + 0.3*\\sin(2*x)*\\cos(2*y)) * (1 + 0.2*\\sin(T*2))' },
                        { name: 'Dragon Scales', equation: '3*\\sin(x*0.8)*\\sin(y*0.8) + 2*\\cos(x*1.2 + y*0.6)*\\sin(y*1.5 - x*0.3) + 0.5*\\sin(T + x + y)' },
                        { name: 'Quantum Field', equation: '5*e^(-0.05*(x^2+y^2))*\\cos(\\sqrt{x^2+y^2} - T) + 2*\\sin(x*0.5)*\\cos(y*0.5)*e^(-0.02*(x^2+y^2))' },
                        { name: 'Galactic Spiral', equation: '3*\\cos(2*atan2(y,x) + 0.1*\\sqrt{x^2+y^2) - T) * e^(-0.05*(x^2+y^2)) + \\sqrt{x^2+y^2}*0.1' },
                        { name: 'Morphing Lotus', equation: '4*\\cos(4*atan2(y,x) + T*0.5) * e^(-0.1*(x^2+y^2)) + 2*\\sin(\\sqrt{x^2+y^2} - T)' },
                        { name: 'Fractal Wave', equation: '3*\\sin(x) + 1.5*\\sin(2*x + y) + 0.7*\\sin(4*x + 2*y + T) + 0.3*\\sin(8*x + 4*y - T*2)' },
                        { name: 'Volcanic Crater', equation: '8*e^(-0.3*(x^2+y^2)) - 12*e^(-0.8*(x^2+y^2)) + 2*\\sin(5*atan2(y,x) + T)*e^(-0.2*(x^2+y^2))' },
                    ],
                    parametric: [
                        { name: 'Pulsing Sphere', xExpr: '(5+2*\\sin(T))\\cos(u)\\sin(v)', yExpr: '(5+2*\\sin(T))\\sin(u)\\sin(v)', zExpr: '(5+2*\\sin(T))\\cos(v)', uMax: 6.28, vMax: 3.14 },
                        { name: 'Wavy Torus', xExpr: '(5+2*\\cos(u))\\cos(v)', yExpr: '(5+2*\\cos(u))\\sin(v)', zExpr: '2*\\sin(u) + \\sin(v*5 + T*2)', uMax: 6.28, vMax: 6.28 },
                        { name: 'Seashell', xExpr: 'u/2*(1-u/(2*pi))*\\cos(u)*(1+\\cos(v))', yExpr: 'u/2*(1-u/(2*pi))*\\sin(u)*(1+\\cos(v))', zExpr: 'u/2*(1-u/(2*pi))*\\sin(v) + 2*u/(2*pi)', uMin: 0, uMax: 6.28, vMin: 0, vMax: 6.28, quality: 150 },
                        { name: 'Mbius Strip', xExpr: '(4+v*\\cos(u/2))\\cos(u)', yExpr: '(4+v*\\cos(u/2))\\sin(u)', zExpr: 'v*\\sin(u/2)', uMax: 6.28, vMin: -1.5, vMax: 1.5, quality: 100 },
                        { name: 'Klein Bottle', xExpr: '(2.5+\\cos(u/2)*\\sin(v)-\\sin(u/2)*\\sin(2*v))*\\cos(u)', yExpr: '(2.5+\\cos(u/2)*\\sin(v)-\\sin(u/2)*\\sin(2*v))*\\sin(u)', zExpr: '\\sin(u/2)*\\sin(v)+\\cos(u/2)*\\sin(2*v)', uMax: 6.28, vMax: 6.28, quality: 150 },
                        { name: 'Helicoid', xExpr: 'u*\\cos(v)', yExpr: 'u*\\sin(v)', zExpr: '1.5*v', uMin: -5, uMax: 5, vMin: -10, vMax: 10, quality: 80 },
                        { name: 'Torus Knot (3,2)', xExpr: '(3+\\cos(3*u + T*0.5))*\\cos(2*u)', yExpr: '(3+\\cos(3*u + T*0.5))*\\sin(2*u)', zExpr: '\\sin(3*u + T*0.3)', uMax: 6.28, quality: 150 },
                        { name: 'Dini\'s Surface', xExpr: '3*cos(u)*sin(v)', yExpr: '3*sin(u)*sin(v)', zExpr: '3*(cos(v) + log(tan(v/2))) + 0.5*u', uMax: 6.28, vMin: 0.1, vMax: 2, quality: 100 },
                        { name: 'Twisted Ribbon', xExpr: '(4 + u*\\cos(3*v + T))*\\cos(v)', yExpr: '(4 + u*\\cos(3*v + T))*\\sin(v)', zExpr: 'u*\\sin(3*v + T) + 2*\\sin(v*2)', uMin: -1, uMax: 1, vMax: 6.28, quality: 100 },
                        { name: 'Nautilus Shell', xExpr: 'e^(u*0.3)*\\cos(u)*\\cos(v)', yExpr: 'e^(u*0.3)*\\sin(u)*\\cos(v)', zExpr: 'e^(u*0.3)*\\sin(v) + u*0.1', uMin: 0, uMax: 15, vMin: -1.57, vMax: 1.57, quality: 150 },
                    ],
                    curve: [
                        { name: 'Wobble Helix', xExpr: '(3+\\sin(T*2)) * \\cos(t)', yExpr: '(3+\\sin(T*2)) * \\sin(t)', zExpr: '0.5*t', tMax: 30 },
                        { name: 'Trefoil Knot', xExpr: '\\sin(t)+2*\\sin(2*t)', yExpr: '\\cos(t)-2*\\cos(2*t)', zExpr: '-\\sin(3*t)', tMax: 6.28, quality: 800 },
                        { name: 'Lissajous 3D', xExpr: '4*\\sin(3*t + T)', yExpr: '4*\\cos(5*t)', zExpr: '4*\\sin(4*t)', tMax: 6.28, quality: 1000 },
                        { name: 'Butterfly 3D', xExpr: '4*\\sin(t)*(e^\\cos(t)-2*\\cos(4*t)-(\\sin(t/12))^5)', yExpr: '4*\\cos(t)*(e^\\cos(t)-2*\\cos(4*t)-(\\sin(t/12))^5)', zExpr: '2*\\cos(T/2)', tMin: 0, tMax: 12.56, quality: 1000 },
                        { name: 'Spiral Sphere', xExpr: '5*\\cos(t)*\\sin(t*0.2)', yExpr: '5*\\sin(t)*\\sin(t*0.2)', zExpr: '5*\\cos(t*0.2)', tMax: 62.8, quality: 1500 },
                        { name: 'Figure-Eight Knot', xExpr: '(2+\\cos(2*t))*\\cos(3*t)', yExpr: '(2+\\cos(2*t))*\\sin(3*t)', zExpr: '\\sin(4*t) + 0.5*\\sin(8*t)', tMax: 6.28, quality: 1000 },
                        { name: 'Viviani\'s Curve', xExpr: '2.5*(1+\\cos(t))', yExpr: '2.5*\\sin(t)', zExpr: '5*\\sin(t/2)', tMin: -6.28, tMax: 6.28, quality: 800 },
                        { name: 'Tornado Spiral', xExpr: '(10 - t*0.2)*\\cos(t*2)', yExpr: '(10 - t*0.2)*\\sin(t*2)', zExpr: 't', tMin: 0, tMax: 40, quality: 1200 },
                        { name: 'Lorenz Attractor', xExpr: '10*(sin(t*0.1) - cos(t*0.07))', yExpr: '28*sin(t*0.1) - cos(t*0.1)*sin(t*0.05)', zExpr: 'sin(t*0.1)*cos(t*0.07) - 8/3*sin(t*0.05)', tMax: 200, quality: 2000 },
                    ],
                    vector: [
                        { name: 'Rotational Flow', fx: '-y*\\cos(T)', fy: 'x*\\cos(T)', fz: '0.5*sin(T*2)' },
                        { name: 'Pulsing Source/Sink', fx: 'x*\\cos(T)', fy: 'y*\\cos(T)', fz: 'z*\\cos(T)' },
                        { name: 'Magnetic Field', fx: 'y', fy: 'z', fz: 'x', zMin: -2, zMax: 2, density: 12 },
                        { name: 'Vortex', fx: '-y/(x^2+y^2+0.1)', fy: 'x/(x^2+y^2+0.1)', fz: '0' },
                        { name: 'Saddle Flow', fx: 'x', fy: '-y', fz: '0' },
                        { name: 'Spiral Sink', fx: '(-x - 2*y)/sqrt(x^2+y^2+0.1)', fy: '(2*x - y)/sqrt(x^2+y^2+0.1)', fz: '-2*z' },
                        { name: 'Wave Field', fx: 'sin(z - T)', fy: 'cos(x - T)', fz: 'sin(y - T)' },
                        { name: 'Tornado', fx: '-y*exp(-0.1*(x^2+y^2))', fy: 'x*exp(-0.1*(x^2+y^2))', fz: '2 - 0.1*(x^2+y^2)' },
                    ],
                    implicit: [
                        { name: 'Sphere', equation: 'x^2+y^2+z^2-16' },
                        { name: 'Animated Torus', equation: '(x^2+y^2+z^2+12 - 4*sin(T))^2 - 64*(x^2+y^2)', quality: 70 },
                        { name: 'Gyroid', equation: '\\cos(x)*\\sin(y)+\\cos(y)*\\sin(z)+\\cos(z)*\\sin(x)', quality: 60 },
                        { name: 'Heart', equation: '(x^2 + (9/4)*y^2 + z^2 - 1)^3 - x^2*z^3 - (9/80)*y^2*z^3', quality: 80 },
                        { name: 'Metaballs', equation: '1/((x-2*sin(T))^2 + y^2 + z^2) + 1/((x+2*sin(T))^2 + y^2 + z^2) + 0.5/((x)^2 + (y-2*cos(T))^2 + z^2) - 1.2', quality: 70 },
                        { name: 'Barth Sextic', equation: '4*((1.618^2)*x^2-y^2)*((1.618^2)*y^2-z^2)*((1.618^2)*z^2-x^2) - (1+2*1.618)*(x^2+y^2+z^2-1.5)^2', quality: 90 },
                        { name: 'Quantum Bubble', equation: 'x^2 + y^2 + z^2 - (4 + 2*sin(5*atan2(y,x))*sin(5*atan2(z,sqrt(x^2+y^2))))', quality: 80 },
                        { name: 'Stellar Formation', equation: 'x^2 + y^2 + z^2 - (9 + 3*sin(8*atan2(y,x))*cos(8*atan2(z,sqrt(x^2+y^2))))', quality: 90 },
                    ],
                    'single-vector': [
                        { name: 'Basic', ox: 0, oy: 0, oz: 0, vx: 5, vy: 5, vz: 5, color: '#ffaa00' },
                        { name: 'Offset', ox: -2, oy: -2, oz: 0, vx: 4, vy: 4, vz: 4, color: '#00aaff' },
                        { name: 'Vertical', ox: 0, oy: 0, oz: -5, vx: 0, vy: 0, vz: 10, color: '#ff4444' },
                    ]
                };
            
                this.playgroundPresets = {
                    'Atom': [
                        // --- NUCLEUS ---
                        // Protons (Red)
                        { type: 'parametric', name: 'Proton 1', config: { xExpr: '0.3*cos(u)*sin(v)', yExpr: '0.3*sin(u)*sin(v)', zExpr: '0.3*cos(v)', uMax: 6.28, vMax: 3.14, quality: 20 }, colormap: 'Reds', animation: { modes: { p: true }, T: { max: 6.28 }, speed: 1.2, pos: { x: '0.5 + 0.1*sin(T*1.2)', y: '0.1*cos(T*0.8)', z: '0.1*cos(T*1.2)' } } },
                        { type: 'parametric', name: 'Proton 2', config: { xExpr: '0.3*cos(u)*sin(v)', yExpr: '0.3*sin(u)*sin(v)', zExpr: '0.3*cos(v)', uMax: 6.28, vMax: 3.14, quality: 20 }, colormap: 'Reds', animation: { modes: { p: true }, T: { max: 6.28 }, speed: 1.2, pos: { x: '-0.25+0.1*cos(T*1.5)', y: '0.43+0.1*sin(T*1.5)', z: '0' } } },
                        { type: 'parametric', name: 'Proton 3', config: { xExpr: '0.3*cos(u)*sin(v)', yExpr: '0.3*sin(u)*sin(v)', zExpr: '0.3*cos(v)', uMax: 6.28, vMax: 3.14, quality: 20 }, colormap: 'Reds', animation: { modes: { p: true }, T: { max: 6.28 }, speed: 1.2, pos: { x: '-0.25+0.1*sin(T)', y: '-0.43+0.1*cos(T)', z: '0' } } },
                        // Neutrons (Grey)
                        { type: 'parametric', name: 'Neutron 1', config: { xExpr: '0.3*cos(u)*sin(v)', yExpr: '0.3*sin(u)*sin(v)', zExpr: '0.3*cos(v)', uMax: 6.28, vMax: 3.14, quality: 20 }, colormap: 'Greys', animation: { modes: { p: true }, T: { max: 6.28 }, speed: 1.2, pos: { x: '0', y: '0.1*sin(T*1.3)', z: '0.5+0.1*sin(T*1.1)' } } },
                        { type: 'parametric', name: 'Neutron 2', config: { xExpr: '0.3*cos(u)*sin(v)', yExpr: '0.3*sin(u)*sin(v)', zExpr: '0.3*cos(v)', uMax: 6.28, vMax: 3.14, quality: 20 }, colormap: 'Greys', animation: { modes: { p: true }, T: { max: 6.28 }, speed: 1.2, pos: { x: '0', y: '0.1*cos(T*1.7)', z: '-0.5+0.1*cos(T*1.4)' } } },
                        { type: 'parametric', name: 'Neutron 3', config: { xExpr: '0.3*cos(u)*sin(v)', yExpr: '0.3*sin(u)*sin(v)', zExpr: '0.3*cos(v)', uMax: 6.28, vMax: 3.14, quality: 20 }, colormap: 'Greys', animation: { modes: { p: true }, T: { max: 6.28 }, speed: 1.2, pos: { x: '0.1*sin(T*1.8)', y: '0.8+0.1*cos(T*1.8)', z: '0' } } },
                        { type: 'parametric', name: 'Neutron 4', config: { xExpr: '0.3*cos(u)*sin(v)', yExpr: '0.3*sin(u)*sin(v)', zExpr: '0.3*cos(v)', uMax: 6.28, vMax: 3.14, quality: 20 }, colormap: 'Greys', animation: { modes: { p: true }, T: { max: 6.28 }, speed: 1.2, pos: { x: '0.1*cos(T*2.2)', y: '-0.8+0.1*sin(T*2.2)', z: '0' } } },
                        // Nucleus Shell (Transparent)
                        { type: 'parametric', name: 'Nucleus Shell', config: { xExpr: '1.2*cos(u)*sin(v)', yExpr: '1.2*sin(u)*sin(v)', zExpr: '1.2*cos(v)', uMax: 6.28, vMax: 3.14, quality: 40, opacity: 0.2 }, colormap: 'Greys' },

                        // --- ELECTRONS & ORBITS ---
                        // Electron 1 (Inner Orbit)
                        { type: 'curve', name: 'Electron Path 1', colormap: 'Plasma', config: { xExpr: '8*cos(t)', yExpr: '8*sin(t)*cos(0.5)', zExpr: '8*sin(t)*sin(0.5)', tMax: 6.28, quality: 400 } },
                        { type: 'parametric', name: 'Electron 1', config: { xExpr: '0.2*cos(u)*sin(v)', yExpr: '0.2*sin(u)*sin(v)', zExpr: '0.2*cos(v)', uMax: 6.28, vMax: 3.14, quality: 10 }, colormap: 'Blues', animation: { modes: { p: true }, T: { max: 6.28 }, speed: 1.2, pos: { x: '8*cos(T)', y: '8*sin(T)*cos(0.5)', z: '8*sin(T)*sin(0.5)' } } },
                        
                        // Electron 2 (Perpendicular Orbit)
                        { type: 'curve', name: 'Electron Path 2', colormap: 'Viridis', config: { xExpr: '10*cos(t)', yExpr: '2*sin(t)', zExpr: '10*sin(t)', tMax: 6.28, quality: 400 } },
                        { type: 'parametric', name: 'Electron 2', config: { xExpr: '0.2*cos(u)*sin(v)', yExpr: '0.2*sin(u)*sin(v)', zExpr: '0.2*cos(v)', uMax: 6.28, vMax: 3.14, quality: 10 }, colormap: 'Blues', animation: { modes: { p: true }, T: { max: 6.28 }, speed: 1.0, pos: { x: '10*cos(T)', y: '2*sin(T)', z: '10*sin(T)' } } },

                        // Electron 3 (Outer Wavy Orbit)
                        { type: 'curve', name: 'Electron Path 3', colormap: 'Jet', config: { xExpr: '12*cos(t)', yExpr: '12*sin(t)', zExpr: '1.5*cos(t*3)', tMax: 6.28, quality: 400 } },
                        { type: 'parametric', name: 'Electron 3', config: { xExpr: '0.2*cos(u)*sin(v)', yExpr: '0.2*sin(u)*sin(v)', zExpr: '0.2*cos(v)', uMax: 6.28, vMax: 3.14, quality: 10 }, colormap: 'Blues', animation: { modes: { p: true }, T: { max: 6.28 }, speed: 0.8, pos: { x: '12*cos(T)', y: '12*sin(T)', z: '1.5*cos(T*3)' } } }
                    ],
                    'Quantum Vortex': [
                        { type: 'parametric', name: 'Quantum Core', config: { xExpr: '(2 + 0.5*sin(8*u + T*3))*cos(u)*cos(v)', yExpr: '(2 + 0.5*sin(8*u + T*3))*cos(u)*sin(v)', zExpr: '(2 + 0.5*sin(8*u + T*3))*sin(u)', uMin: -1.57, uMax: 1.57, vMax: 6.28, quality: 80 }, colormap: 'Plasma', animation: { modes: { v: true, p: true }, T: { max: 6.28 }, speed: 1.5, rot: { x: 'T*20', y: 'T*30', z: 'T*15' } } },
                        { type: 'curve', name: 'EM Spiral 1', config: { xExpr: 't*0.3*cos(t*2 + T)', yExpr: 't*0.3*sin(t*2 + T)', zExpr: 't*0.1*sin(t*0.5 + T*2)', tMin: 0, tMax: 25, quality: 800 }, colormap: 'Viridis', animation: { modes: { v: true }, T: { max: 6.28 }, speed: 2 } },
                        { type: 'curve', name: 'EM Spiral 2', config: { xExpr: 't*0.3*cos(t*2 + T + 2.09)', yExpr: 't*0.3*sin(t*2 + T + 2.09)', zExpr: 't*0.1*sin(t*0.5 + T*2 + 1)', tMin: 0, tMax: 25, quality: 800 }, colormap: 'Blues', animation: { modes: { v: true }, T: { max: 6.28 }, speed: 1.8 } },
                        { type: 'curve', name: 'EM Spiral 3', config: { xExpr: 't*0.3*cos(t*2 + T + 4.19)', yExpr: 't*0.3*sin(t*2 + T + 4.19)', zExpr: 't*0.1*sin(t*0.5 + T*2 + 2)', tMin: 0, tMax: 25, quality: 800 }, colormap: 'Reds', animation: { modes: { v: true }, T: { max: 6.28 }, speed: 2.2 } },
                        { type: 'curve', name: 'Gravity Wave 1', config: { xExpr: '(8 + 2*sin(T*4))*cos(t)', yExpr: '(8 + 2*sin(T*4))*sin(t)', zExpr: '3*sin(t*3 + T*5)', tMax: 6.28, quality: 200 }, colormap: 'Hot', animation: { modes: { v: true }, T: { max: 6.28 }, speed: 1 } },
                        { type: 'curve', name: 'Gravity Wave 2', config: { xExpr: '(12 + 1.5*cos(T*3))*cos(t)', yExpr: '(12 + 1.5*cos(T*3))*sin(t)', zExpr: '2*cos(t*4 + T*3)', tMax: 6.28, quality: 200 }, colormap: 'Purples', animation: { modes: { v: true }, T: { max: 6.28 }, speed: 0.7 } },
                        { type: 'surface', name: 'Quantum Field', config: { equation: '3*e^(-0.03*(x^2+y^2))*cos(sqrt(x^2+y^2)*0.8 - T*2) + 2*sin(x*0.3)*cos(y*0.3)*e^(-0.01*(x^2+y^2))', xMin: -15, xMax: 15, yMin: -15, yMax: 15, quality: 100 }, colormap: 'Jet', animation: { modes: { v: true }, T: { max: 6.28 }, speed: 1.2 } },
                        { type: 'curve', name: 'Particle Stream 1', config: { xExpr: '15*cos(t*0.1 + T*5)', yExpr: '15*sin(t*0.1 + T*5)', zExpr: 't*0.05', tMin: -100, tMax: 100, quality: 400 }, colormap: 'Oranges', animation: { modes: { v: true }, T: { max: 6.28 }, speed: 3 } },
                        { type: 'curve', name: 'Particle Stream 2', config: { xExpr: '15*cos(t*0.1 + T*5 + 3.14)', yExpr: '15*sin(t*0.1 + T*5 + 3.14)', zExpr: 't*0.05', tMin: -100, tMax: 100, quality: 400 }, colormap: 'Greens', animation: { modes: { v: true }, T: { max: 6.28 }, speed: 2.5 } }
                    ],
                    'Quantum Entanglement': [
                        { type: 'parametric', name: 'Core A', config: { xExpr: '(1.5 + 0.5*sin(T*3))*cos(u)*sin(v)', yExpr: '(1.5 + 0.5*sin(T*3))*sin(u)*sin(v)', zExpr: '(1.5 + 0.5*sin(T*3))*cos(v)', uMax: 6.28, vMax: 3.14, quality: 50 }, colormap: 'Hot', animation: { modes: { v: true, p: true }, T: { min: 0, max: 6.28 }, speed: 0.5, pos: { x: '5*cos(T*0.5)', y: '5*sin(T*0.5)', z: '2*sin(T)' } } },
                        { type: 'parametric', name: 'Core B', config: { xExpr: '(1.5 + 0.5*sin(T*3))*cos(u)*sin(v)', yExpr: '(1.5 + 0.5*sin(T*3))*sin(u)*sin(v)', zExpr: '(1.5 + 0.5*sin(T*3))*cos(v)', uMax: 6.28, vMax: 3.14, quality: 50 }, colormap: 'Plasma', animation: { modes: { v: true, p: true }, T: { min: 0, max: 6.28 }, speed: 0.5, pos: { x: '-5*cos(T*0.5)', y: '-5*sin(T*0.5)', z: '-2*sin(T)' } } },
                        { type: 'parametric', name: 'Entanglement Ribbon', config: { xExpr: 'u', yExpr: 'v*sin(u*0.4 + T*2)', zExpr: 'v*cos(u*0.4 + T*2)', uMin: -5, uMax: 5, vMin: -0.5, vMax: 0.5, quality: 100 }, colormap: 'Viridis', animation: { modes: { v: true, p: true }, T: { min: 0, max: 6.28 }, speed: 0.5, rot: { y: '-(T*0.5*57.3)', z: 'T*0.1*57.3' }, scale: { y: '1.5 + cos(T)', z: '1.5 + cos(T)' } } },
                        { type: 'implicit', name: 'Quantum Field', config: { equation: 'cos(x/2)*sin(y/2) + cos(y/2)*sin(z/2) + cos(z/2)*sin(x/2) - sin(T)*0.2', xMin: -10, xMax: 10, yMin: -10, yMax: 10, zMin: -10, zMax: 10, quality: 40, opacity: 0.3 }, colormap: 'Greys', animation: { modes: { v: true }, T: { min: 0, max: 6.28 }, speed: 0.5 } }
                    ],
                    'Cosmic Dance': [
                        { type: 'implicit', name: 'Cosmic Core', config: { equation: 'x^2 + y^2 + z^2 - (4 + 2*sin(5*atan2(y,x) + T*2)*cos(5*atan2(z,sqrt(x^2+y^2)) + T))', quality: 90 }, colormap: 'Hot', animation: { modes: { v: true }, T: { max: 6.28 }, speed: 1 } },
                        { type: 'curve', name: 'Orbital Path 1', config: { xExpr: '8*cos(t)*cos(t*0.1 + T)', yExpr: '8*sin(t)*cos(t*0.1 + T)', zExpr: '5*sin(t*0.1 + T)', tMax: 62.8, quality: 1000 }, colormap: 'Plasma', animation: { modes: { v: true }, T: { max: 6.28 }, speed: 1.5 } },
                        { type: 'curve', name: 'Orbital Path 2', config: { xExpr: '12*cos(t*0.7)*sin(t*0.05 + T*0.8)', yExpr: '12*sin(t*0.7)*sin(t*0.05 + T*0.8)', zExpr: '8*cos(t*0.05 + T*0.8)', tMax: 125.6, quality: 1200 }, colormap: 'Viridis', animation: { modes: { v: true }, T: { max: 6.28 }, speed: 0.8 } },
                        { type: 'surface', name: 'Wave Field', config: { equation: '4*sin(sqrt((x-5*cos(T))^2 + (y-5*sin(T))^2)*0.5 - T*3) + 4*sin(sqrt((x+5*cos(T))^2 + (y+5*sin(T))^2)*0.5 + T*2)', xMin: -20, xMax: 20, yMin: -20, yMax: 20, quality: 120 }, colormap: 'Cool', animation: { modes: { v: true }, T: { max: 6.28 }, speed: 1.2 } }
                    ],
                }
            }

            renderPresets() {
                const container = document.getElementById('presets-container');
                if (!container) return;
                container.innerHTML = '';
            
                const presetsSource = this.currentMode === 'playground' ? this.playgroundPresets : this.presets[this.currentMode];
                if (!presetsSource) return;
            
                
                if (this.currentMode === 'playground') {
                    Object.entries(presetsSource).forEach(([name, data]) => {
                        const card = document.createElement('button');
                        card.className = 'preset-card btn btn-secondary text-xs transition-all duration-200';
                        card.textContent = name; 
                        card.onclick = () => { this.loadPlaygroundPreset(data); };
                        container.appendChild(card);
                    });
                } else {
                    
                    presetsSource.forEach(presetData => {
                        const card = document.createElement('button');
                        card.className = 'preset-card btn btn-secondary text-xs transition-all duration-200';
                        card.textContent = presetData.name; 
                        card.onclick = () => { this.loadPreset(presetData); };
                        container.appendChild(card);
                    });
                }
            }

            loadPlaygroundPreset(presetObjects) {
                this.stopAllAnimations();
                this.playgroundObjects = [];
                this.focusedObjectId = null;
                this.plotter.clearPlots();
                this.plotQueue = []; 
            
                presetObjects.forEach(presetObj => {
                    const newObject = this.addPlaygroundObject(presetObj.type, false); 
                    newObject.name = presetObj.name;
                    newObject.config = { ...newObject.config, ...presetObj.config };
                    if (presetObj.colormap) newObject.colormap = presetObj.colormap;
                    if (presetObj.animation) {
                        newObject.animation = $.extend(true, {}, this.getDefaultAnimationConfig(newObject.type), presetObj.animation);
                    }
                    
                    this.plotQueue.push(newObject.id); 
                });
            
                this.renderPlaygroundUI();
                this.renderGlobalAnimationTray();
            
                
                this.processNextInQueue();
            }

            loadPreset(preset) {
                if (this.currentMode === 'playground' || this.playgroundObjects.length === 0) return;
                const obj = this.playgroundObjects[0];
                if (!obj || obj.type !== this.currentMode) return;

                this.hideError(obj.id);
                this.stopAnimation(obj.id);
                obj.config = { ...this.getDefaultConfig(obj.type), ...preset };

                this.renderPlaygroundUI();
                this.renderGlobalAnimationTray();
                this.plot(obj.id);
            }

            renderColormapSelector(container, currentMap, callback) {
                if (!container) return;
            
                const importantColormaps = {
                    'Plasma': this.colormaps['Plasma'],
                    'Viridis': this.colormaps['Viridis'],
                    'Jet': this.colormaps['Jet'],
                    'Hot': this.colormaps['Hot'],
                    'Greys': this.colormaps['Greys']
                };
            
                container.innerHTML = '';
                Object.entries(importantColormaps).forEach(([id, { name, gradient }]) => {
                    const button = document.createElement('button');
                    button.className = 'colormap-btn h-8 w-full';
                    button.title = name;
                    button.style.background = gradient;
            
                    if (id === currentMap) {
                        button.classList.add('active');
                    }
            
                    button.addEventListener('click', () => {
                        callback(id);
                        container.querySelectorAll('.colormap-btn').forEach(btn => btn.classList.remove('active'));
                        button.classList.add('active');
                        this.plotter.updateSinglePlot(this.getPlaygroundObject(container.closest('[data-object-id]').dataset.objectId), document.getElementById('wireframe-toggle').checked);
                    });
                    container.appendChild(button);
                });
            }

            fitViewToObjects() {
                const combinedBounds = new THREE.Box3();
                let hasContent = false;
            
                // Calculate the total bounds of all visible objects
                this.playgroundObjects.forEach(obj => {
                    if (obj.visible && obj.threeMesh) {
                        const objectBounds = this.plotter.calculateObjectBounds(obj.threeMesh);
                        if (!objectBounds.isEmpty()) {
                            combinedBounds.union(objectBounds);
                            hasContent = true;
                        }
                    }
                });
            
                // If there's anything to frame, update the grid
                if (hasContent) {
                    const size = combinedBounds.getSize(new THREE.Vector3());
                    const padding = size.length() * 0.1; // Add 10% padding
                    combinedBounds.expandByScalar(padding > 0.5 ? padding : 0.5);
            
                    // We need a way to tell the plotter to use these new bounds
                    this.plotter.setGridBounds(combinedBounds);
                } else {
                    this.showToast("No objects to fit view to.");
                }
            }

            startTutorial() {
                this.tutorialIsActive = true;
                this.currentTutorialStep = 0;
                document.getElementById('tutorial-modal-overlay')?.classList.remove('hidden');
                
                // This check prevents adding a new object if the Atom preset is already loaded
                if(this.playgroundObjects.length === 0) {
                    this.addPlaygroundObject('surface', true);
                }
                this.showTutorialStep(this.currentTutorialStep);
            }
            
            endTutorial() {
                document.getElementById('tutorial-modal-overlay')?.classList.add('hidden');
                document.getElementById('tutorial-highlighter').style.display = 'none';
                localStorage.setItem('plotterProTutorialCompleted', 'true');
                this.tutorialIsActive = false;
                this.renderGlobalAnimationTray();
            
                // Start the animations after the tutorial is done
                this.playAllAnimations();
            }
            
            showTutorialStep(stepIndex) {
                const step = this.tutorialSteps[stepIndex];
                if (!step) return;
            
                document.getElementById('tutorial-title').textContent = step.title;
                document.getElementById('tutorial-text').textContent = step.text;
                document.getElementById('tutorial-counter').textContent = `${stepIndex + 1} / ${this.tutorialSteps.length}`;
            
                const highlighter = document.getElementById('tutorial-highlighter');
                const modalPanel = document.getElementById('tutorial-modal-panel');
                const targetElement = step.selector ? document.querySelector(step.selector) : null;
            
                if (targetElement) {
                    const rect = targetElement.getBoundingClientRect();
                    highlighter.style.display = 'block';
                    highlighter.style.top = `${rect.top - 4}px`;
                    highlighter.style.left = `${rect.left - 4}px`;
                    highlighter.style.width = `${rect.width + 8}px`;
                    highlighter.style.height = `${rect.height + 8}px`;
                    
                    
                    modalPanel.style.position = 'fixed'; 
                    modalPanel.style.transform = 'none'; 
            
                    
                    let top = rect.bottom + 15;
                    if (top + modalPanel.offsetHeight > window.innerHeight) {
                        top = rect.top - modalPanel.offsetHeight - 15;
                    }
            
                    
                    let left = rect.left;
                    if (left + modalPanel.offsetWidth > window.innerWidth) {
                        left = window.innerWidth - modalPanel.offsetWidth - 15;
                    }
                    
                    
                    if (left < 15) left = 15;
                    if (top < 15) top = 15;
            
                    modalPanel.style.top = `${top}px`;
                    modalPanel.style.left = `${left}px`;
                    
                } else {
                    
                    highlighter.style.display = 'none';
                    modalPanel.style.position = 'relative'; 
                    modalPanel.style.top = 'auto';
                    modalPanel.style.left = 'auto';
                    modalPanel.style.transform = 'none';
                }
            
                document.getElementById('tutorial-prev-btn').style.visibility = (stepIndex === 0) ? 'hidden' : 'visible';
                const nextButton = document.getElementById('tutorial-next-btn');
                nextButton.textContent = (stepIndex === this.tutorialSteps.length - 1) ? 'Finish' : 'Next';
            }

            switchMode(mode, initial = false) {
                this.stopAllAnimations();

                this.syncUItoState();
                if (this.currentMode && this.playgroundObjects.length > 0) {
                    this.modeStates[this.currentMode] = this.playgroundObjects;
                }

                this.currentMode = mode;
                this.activeMathFieldId = null;
                this.focusedObjectId = null;
                this.modeTabs.forEach(tab => tab.classList.toggle('active', tab.dataset.mode === mode));

                this.playgroundObjects = this.modeStates[mode] || [];

                if (mode === 'playground') {
                    this.singleModeControls.classList.add('hidden');
                    this.playgroundControls.classList.remove('hidden');
                    this.presetsTitle.textContent = 'Playground Presets';
                    if (this.playgroundObjects.length === 0 && !initial) {
                        this.addPlaygroundObject('surface', true);
                    }
                } else {
                    this.singleModeControls.classList.remove('hidden');
                    this.playgroundControls.classList.add('hidden');
                    this.presetsTitle.textContent = 'Presets';

                    const configContainer = this.singleModeControls.querySelector('.accordion-content .space-y-5');
                    if (configContainer) {
                        configContainer.querySelectorAll(':scope > div').forEach(div => div.classList.add('hidden'));
                    
                        const currentControls = configContainer.querySelector(`.${mode}-controls`);
                        if (currentControls) {
                            currentControls.classList.remove('hidden');
                        }else{this.showToast(`[Debug] CRITICAL: Could not find controls container for mode: .${mode}-controls`);}
                    }

                    if (this.playgroundObjects.length === 0) {
                        this.addPlaygroundObject(mode, !initial);
                        this.modeStates[mode] = this.playgroundObjects;
                    }
                }

                this.renderPlaygroundUI();
                this.renderPresets();
                this.renderGlobalAnimationTray();
                this.plotter.clearPlots();
                this.playgroundObjects.forEach(obj => {
                    this.plot(obj.id);
                });
                this.updateGlobalPlayPauseButton();
            }

            addPlaygroundObject(type, shouldPlot = true) {
                const id = `obj_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;
                const preset = this.presets[type]?.[0] || {};
                const newObject = {
                    id: id, type: type,
                    name: `${type.replace('-', ' ').replace(/\b\w/g, l => l.toUpperCase())} ${this.playgroundObjects.filter(o => o.type === type).length + 1}`,
                    visible: true, config: this.getDefaultConfig(type, preset),
                    colormap: 'Plasma',
                    lastData: null,
                    threeMesh: null,
                    animation: this.getDefaultAnimationConfig(type)
                };
                this.playgroundObjects.push(newObject);
                this.renderPlaygroundUI();
                this.renderGlobalAnimationTray();
                this.plotter.updateAxesAndGrid();
                if (shouldPlot) this.plot(id);
                return newObject;
            }

            removePlaygroundObject(id) {
                this.stopAnimation(id);
                if(this.focusedObjectId === id) this.setFocus(null);
                const obj = this.getPlaygroundObject(id);
                if (obj && obj.threeMesh) {
                     this.plotter.plotGroup.remove(obj.threeMesh);
                }
                this.playgroundObjects = this.playgroundObjects.filter(obj => obj.id !== id);
                this.renderPlaygroundUI();
                this.renderGlobalAnimationTray();
                this.plotter.updateAxesAndGrid();
                this.renderAllPlots();
            }

            setFocus(id) {
                this.focusedObjectId = id;
                document.querySelectorAll('.playground-object').forEach(el => {
                    el.classList.toggle('focused', el.dataset.objectId === id);
                });
                this.plotter.updateAxesAndGrid();
            }

            getPlaygroundObject(id) { return this.playgroundObjects.find(obj => obj.id === id); }
            getPlaygroundObjectByMesh(mesh) {
                if (!mesh.userData.objectId) return null;
                return this.getPlaygroundObject(mesh.userData.objectId);
            }

            getDefaultConfig(type, preset = {}) {
                const baseConfig = { quality: 100, opacity: 1.0 };
                switch(type) {
                    case 'surface': return { ...baseConfig, equation: 'x^2-y^2', xMin: -5, xMax: 5, yMin: -5, yMax: 5, ...preset };
                    case 'parametric': return { ...baseConfig, quality: 100, xExpr: 'u', yExpr: 'v', zExpr: 'u*v', uMin: 0, uMax: 6.28, vMin: 0, vMax: 6.28, ...preset };
                    case 'implicit': return { ...baseConfig, quality: 40, equation: 'x^2+y^2+z^2-16', xMin: -5, xMax: 5, yMin: -5, yMax: 5, zMin: -5, zMax: 5, ...preset };
                    case 'curve': return { ...baseConfig, quality: 500, xExpr: '\\cos(t)', yExpr: '\\sin(t)', zExpr: 't', tMin: 0, tMax: 10, ...preset };
                    case 'vector': return { ...baseConfig, density: 10, scale: 1.0, fx: 'x', fy: 'y', fz: '0', xMin: -3, xMax: 3, yMin: -3, yMax: 3, zMin: -3, zMax: 3, ...preset };
                    case 'single-vector': return { ox: 0, oy: 0, oz: 0, vx: 1, vy: 1, vz: 1, color: '#ffffff', ...preset };
                }
                return baseConfig;
            }

            renderPlaygroundUI() {
                if (this.currentMode === 'playground') {
                    this.playgroundObjectsContainer.innerHTML = '';
                    if (this.playgroundObjects.length === 0) {
                        this.playgroundObjectsContainer.innerHTML = `<div class="text-center text-text-muted p-8 border-2 border-dashed border-border-color rounded-lg">
                            <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="mx-auto mb-4"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg>
                            <h3 class="text-lg font-semibold text-text-light">Empty Playground</h3>
                            <p>Click "Add Object" to start plotting.</p>
                        </div>`;
                    } else {
                        this.playgroundObjects.forEach(obj => {
                            const div = document.createElement('div');
                            div.className = 'playground-object';
                            if(this.focusedObjectId === obj.id) div.classList.add('focused');
                            div.dataset.objectId = obj.id;
                            div.innerHTML = this.getPlaygroundObjectHTML(obj);
                            this.playgroundObjectsContainer.appendChild(div);
                            this.initializeMathFields(div);
                            this.setupPlaygroundObjectListeners(div, obj);
                        });
                    }
                } else {
                    const container = this.singleModeControls.querySelector(`.${this.currentMode}-controls`);
                    if (!container) return;
                    container.innerHTML = '';
                    const obj = this.playgroundObjects[0];
                    if (obj) {
                        const div = document.createElement('div');
                        div.dataset.objectId = obj.id;
                        div.innerHTML = this.getPlaygroundObjectHTML(obj);
                        container.appendChild(div);
                        this.initializeMathFields(div);
                    }
                    this.renderAppearanceSettings();
                }
            }

            setupPlaygroundObjectListeners(div, obj) {
                div.querySelector('.focus-object-btn')?.addEventListener('click', () => this.setFocus(obj.id));
                div.querySelector('.remove-object-btn')?.addEventListener('click', () => this.removePlaygroundObject(obj.id));

                const visibilityBtn = div.querySelector('.toggle-visibility-btn');
                if(visibilityBtn) {
                    visibilityBtn.addEventListener('click', (e) => {
                        obj.visible = !obj.visible;
                        if (obj.threeMesh) {
                            obj.threeMesh.visible = obj.visible;
                            this.applyAdvancedTransforms(obj); 
                        }
                        e.currentTarget.classList.toggle('opacity-50', !obj.visible);
                        this.plotter.updateAxesAndGrid();
                        this.renderAllPlots();
                    });
                }

                const accordionHeader = div.querySelector('.accordion-header');
                if (accordionHeader) {
                    accordionHeader.addEventListener('click', (e) => {
                        if (e.target.closest('button, input')) return;
                        const content = div.querySelector('.accordion-content');
                        const isOpen = content.classList.toggle('open');
                        content.style.maxHeight = isOpen ? content.scrollHeight + 20 + "px" : '0px';
                        e.currentTarget.classList.toggle('open');
                    });
                }

                const appearanceDetails = div.querySelector('.appearance-accordion');
                const mainAccordionContent = div.querySelector('.accordion-content');

                if (appearanceDetails && mainAccordionContent) {
                    appearanceDetails.addEventListener('toggle', () => {
                        if (mainAccordionContent.classList.contains('open')) {
                            mainAccordionContent.style.maxHeight = mainAccordionContent.scrollHeight + 20 + 'px';
                        }
                    });
                }

                const colormapContainer = div.querySelector('.colormap-selector-playground');
                if (colormapContainer) {
                    this.renderColormapSelector(colormapContainer, obj.colormap, (newMap) => {
                        obj.colormap = newMap;
                        this.plotter.updateSinglePlot(obj, document.getElementById('wireframe-toggle').checked);
                    });
                }
            }

            renderAppearanceSettings() {
                const container = document.getElementById('appearance-settings');
                if (!container) return;
            
                const obj = this.playgroundObjects[0];
                if (!obj || obj.type === 'single-vector') { container.innerHTML = ''; return; }
            
                let qualityControlHTML = '';
                const opacityHTML = `<div><label>Opacity: <span class="range-value-display font-mono text-secondary">${parseFloat(obj.config.opacity).toFixed(2)}</span></label><input type="range" min="0" max="1" step="0.05" value="${obj.config.opacity}" data-config="opacity"></div>`;
            
                switch(obj.type) {
                    case 'surface': case 'parametric':
                        qualityControlHTML = `<div><label>Quality: <span class="range-value-display font-mono text-secondary">${obj.config.quality}</span></label><input type="range" min="20" max="200" step="10" value="${obj.config.quality}" data-config="quality"></div>`;
                        break;
                    case 'curve':
                        qualityControlHTML = `<div><label>Quality: <span class="range-value-display font-mono text-secondary">${obj.config.quality}</span></label><input type="range" min="50" max="2000" step="10" value="${obj.config.quality}" data-config="quality"></div>`;
                        break;
                    case 'vector':
                        qualityControlHTML = `
                            <div><label>Density: <span class="range-value-display font-mono text-secondary">${obj.config.density}</span></label><input type="range" min="4" max="40" step="1" value="${obj.config.density}" data-config="density"></div>
                            <div><label>Arrow Scale: <span class="range-value-display font-mono text-secondary">${parseFloat(obj.config.scale).toFixed(2)}</span></label><input type="range" min="0.1" max="3" step="0.05" value="${obj.config.scale}" data-config="scale"></div>`;
                        break;
                }
            
                container.innerHTML = `
                    <div data-object-id="${obj.id}" class="space-y-4">
                        <div class="grid grid-cols-2 gap-4">
                            ${qualityControlHTML}
                            ${opacityHTML}
                        </div>
                        <div>
                            <label>Color Map</label>
                            <div id="single-mode-colormap" class="grid grid-cols-5 gap-2 mt-2"></div>
                        </div>
                        <div class="border-t border-border-color pt-4 mt-4">
                            <label class="flex items-center gap-3 cursor-pointer">
                                <input type="checkbox" data-config="useShader" class="form-checkbox h-5 w-5 text-secondary rounded" ${obj.config.useShader ? 'checked' : ''}>
                                <span class="font-medium">Use Advanced Shading</span>
                            </label>
                            <p class="text-xs text-text-muted mt-1">Note: Advanced shading may not be compatible with the slicing plane feature.</p>
                        </div>
                    </div>`;
            
                const colormapContainer = container.querySelector('#single-mode-colormap');
                this.renderColormapSelector(colormapContainer, obj.colormap, (newMap) => {
                    obj.colormap = newMap;
                    this.plotter.updateSinglePlot(obj, document.getElementById('wireframe-toggle').checked);
                });
            }


            getPlaygroundObjectHTML(obj) {
                const c = obj.config;
                let fieldsHTML = '';
                const isSingleMode = this.currentMode !== 'playground';
            
                const createMathInputGroup = (label, id, latexValue) => `
                    <div class="math-input-group">
                        <div class="flex justify-between items-center mb-1">
                            <label>${label}</label>
                            <div class="math-input-actions">
                                <button title="Copy LaTeX" class="math-input-action-btn" data-action="copy-latex" data-field-id="${id}">L</button>
                                <button title="Copy MathJS" class="math-input-action-btn" data-action="copy-mathjs" data-field-id="${id}">M</button>
                            </div>
                        </div>
                        <div class="math-input-container">
                            <span id="${id}" class="math-input-field">${latexValue}</span>
                            <button class="calc-trigger-btn" data-field-id="${id}" title="Open Calculator">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2"></rect><line x1="8" y1="7" x2="16" y2="7"></line><line x1="8" y1="12" x2="16" y2="12"></line><line x1="8" y1="17" x2="16" y2="17"></line></svg>
                            </button>
                        </div>
                    </div>`;
            
                const createRangeInputs = (vars) => {
                    return vars.map(v => `
                        <div>
                            <label class="uppercase">${v} Range (Min/Max)</label>
                            <div class="grid grid-cols-2 gap-2">
                                <input type="number" step="0.1" value="${c[`${v}Min`]}" class="form-input" data-config="${v}Min">
                                <input type="number" step="0.1" value="${c[`${v}Max`]}" class="form-input" data-config="${v}Max">
                            </div>
                        </div>
                    `).join('');
                };
            
                switch(obj.type) {
                    case 'surface':
                        fieldsHTML = `${createMathInputGroup('z = f(x, y, T)', `eq-${obj.id}`, c.equation)} ${createRangeInputs(['x', 'y'])}`;
                        break;
                    case 'parametric':
                        fieldsHTML = `${createMathInputGroup('x(u,v,T)', `px-${obj.id}`, c.xExpr)} ${createMathInputGroup('y(u,v,T)', `py-${obj.id}`, c.yExpr)} ${createMathInputGroup('z(u,v,T)', `pz-${obj.id}`, c.zExpr)} ${createRangeInputs(['u', 'v'])}`;
                        break;
                    case 'implicit': 
                        fieldsHTML = `${createMathInputGroup('f(x, y, z, T) = 0', `imp-${obj.id}`, c.equation)}`;
                        break;
                    case 'curve':
                        fieldsHTML = `${createMathInputGroup('x(t,T)', `cx-${obj.id}`, c.xExpr)} ${createMathInputGroup('y(t,T)', `cy-${obj.id}`, c.yExpr)} ${createMathInputGroup('z(t,T)', `cz-${obj.id}`, c.zExpr)} ${createRangeInputs(['t'])}`;
                        break;
                    case 'vector':
                        fieldsHTML = `${createMathInputGroup('F_x(x,y,z,T)', `vx-${obj.id}`, c.fx)} ${createMathInputGroup('F_y(x,y,z,T)', `vy-${obj.id}`, c.fy)} ${createMathInputGroup('F_z(x,y,z,T)', `vz-${obj.id}`, c.fz)} ${createRangeInputs(['x', 'y', 'z'])}`;
                        break;
                    case 'single-vector': 
                        fieldsHTML = `<div class="grid grid-cols-2 gap-4 mt-2"> <div> <label>Origin (x, y, z)</label> <div class="grid grid-cols-3 gap-2"> <input type="number" step="0.1" value="${c.ox}" class="form-input w-full text-xs p-1" data-config="ox"> <input type="number" step="0.1" value="${c.oy}" class="form-input w-full text-xs p-1" data-config="oy"> <input type="number" step="0.1" value="${c.oz}" class="form-input w-full text-xs p-1" data-config="oz"> </div> </div> <div> <label>Vector (i, j, k)</label> <div class="grid grid-cols-3 gap-2"> <input type="number" step="0.1" value="${c.vx}" class="form-input w-full text-xs p-1" data-config="vx"> <input type="number" step="0.1" value="${c.vy}" class="form-input w-full text-xs p-1" data-config="vy"> <input type="number" step="0.1" value="${c.vz}" class="form-input w-full text-xs p-1" data-config="vz"> </div> </div> <div class="col-span-2"> <label>Color</label> <input type="color" value="${c.color}" class="form-input w-full h-10 p-1" data-config="color">    <div class="col-span-2"> 
        <label>Color</label> 
        <input type="color" value="${c.color}" class="form-input w-full h-10 p-1" data-config="color"> 
    </div>
    
    <div class="col-span-2">
        <label>Visual Scale: <span class="range-value-display font-mono text-secondary">${parseFloat(c.visualScale || 1.0).toFixed(2)}</span></label>
        <input type="range" min="0.2" max="5" step="0.1" value="${c.visualScale || 1.0}" data-config="visualScale">
    </div> </div> </div>`; 
                        break;
                }
            
                const headerHTML = isSingleMode ? '' : `
                    <div class="accordion-header compact-object-header">
                        <span class="object-name">${obj.name}</span>
                        <div class="object-actions">
                            <button title="Toggle Visibility" class="toggle-visibility-btn tool-button ${obj.visible ? '' : 'opacity-40'}">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg>
                            </button>
                            <button title="Remove Object" class="remove-object-btn tool-button hover:bg-red-500/20 hover:text-red-400">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
                            </button>
                            <span class="chevron-container !w-6 !h-6">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="chevron"><polyline points="6 9 12 15 18 9"></polyline></svg>
                            </span>
                        </div>
                    </div>`;
                
                const contentClass = isSingleMode ? '' : 'accordion-content';
                const paddingClass = isSingleMode ? '' : 'p-3';
                
                let appearanceHTML = '';
                if (!isSingleMode && obj.type !== 'single-vector') {
                    let qualityControlHTML = '';
                    const opacityHTML = `<div><label>Opacity: <span class="range-value-display font-mono text-secondary">${parseFloat(c.opacity).toFixed(2)}</span></label><input type="range" min="0" max="1" step="0.05" value="${c.opacity}" data-config="opacity"></div>`;
                    if (obj.type === 'vector') {
                        qualityControlHTML = `
                            <div><label>Density: <span class="range-value-display font-mono text-secondary">${c.density}</span></label><input type="range" min="4" max="40" step="1" value="${c.density}" data-config="density"></div>
                            <div><label>Arrow Scale: <span class="range-value-display font-mono text-secondary">${parseFloat(c.scale).toFixed(2)}</span></label><input type="range" min="0.1" max="3" step="0.05" value="${c.scale}" data-config="scale"></div>
                        `;
                    } else {
                         qualityControlHTML = `<div><label>Quality: <span class="range-value-display font-mono text-secondary">${c.quality}</span></label><input type="range" min="${obj.type === 'curve' ? 50 : 20}" max="${obj.type === 'curve' ? 2000 : 200}" step="10" value="${c.quality}" data-config="quality"></div>`;
                    }
                    appearanceHTML = `
                        <details class="appearance-accordion border border-border-subtle rounded-lg mt-3">
                            <summary class="p-2 cursor-pointer font-semibold text-sm">Appearance</summary>
                            <div class="p-2 border-t border-border-subtle space-y-3">
                                <div class="grid grid-cols-2 gap-3">
                                    ${qualityControlHTML}
                                    ${opacityHTML}
                                </div>
                                <div>
                                    <label class="text-xs font-medium">Color Map</label>
                                    <div class="colormap-selector-playground grid grid-cols-5 gap-2 mt-1"></div>
                                </div>
                            </div>
                        </details>`;
                }
            
                return `${headerHTML} <div class="${contentClass}"> <div class="${paddingClass} space-y-3"> ${fieldsHTML} ${appearanceHTML} <div id="error-${obj.id}" class="error-badge hidden text-red-400 text-xs p-2 bg-red-500/10 rounded"></div> </div> </div>`;
            }

            renderGlobalAnimationTray() {
                const animatableObjects = this.playgroundObjects.filter(obj => obj.animation);
                const cardsContainer = document.getElementById('animation-cards-container');
            
                if (!cardsContainer) return;
            
                if (animatableObjects.length === 0 && !this.tutorialIsActive) {
                    this.animationTray.classList.add('hidden');
                    return;
                }
            
                this.animationTray.classList.remove('hidden');
                cardsContainer.innerHTML = ''; 
            
                const accentColors = ['var(--color-primary)', 'rgb(34, 197, 94)', 'rgb(236, 72, 153)', 'rgb(250, 204, 21)'];
            
                animatableObjects.forEach((obj, index) => {
                    const anim = obj.animation;
                    const id = obj.id;
                    const themeColor = accentColors[index % accentColors.length];
            
                    const easingOptions = Object.keys(this.Easing).map(name => `<option value="${name}" ${anim.easing === name ? 'selected' : ''}>${name}</option>`).join('');
                    const initialVisiblePanel = 'v'; 
            
                    const controllerHTML = `
                        <div class="anim-tray-controller" data-object-id="${id}" style="--component-accent: ${themeColor};">
                            <header class="anim-tray-header">
                                <h3 title="${obj.name}"><span class="accent-dot"></span> ${obj.name}</h3>
                                <div class="anim-tray-mode-toggle">
                                    <input type="radio" id="panel-v-${id}" name="panel-toggle-${id}" value="v-mode" ${initialVisiblePanel === 'v' ? 'checked' : ''}><label for="panel-v-${id}">V</label>
                                    <input type="radio" id="panel-p-${id}" name="panel-toggle-${id}" value="p-mode" ${initialVisiblePanel === 'p' ? 'checked' : ''}><label for="panel-p-${id}">P</label>
                                    <input type="radio" id="panel-physics-${id}" name="panel-toggle-${id}" value="physics-mode" ${initialVisiblePanel === 'physics' ? 'checked' : ''}><label for="panel-physics-${id}">Physics</label>
                                </div>
                            </header>
                            <section class="anim-tray-player">
                                <button class="icon-btn anim-play-pause"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg></button>
                                <button class="icon-btn anim-reset-btn" title="Reset Animation"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg></button>
                                <button class="icon-btn anim-loop-toggle"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M17 2.1l4 4-4 4"/><path d="M3 12.2v-2a4 4 0 0 1 4-4h12.8"/><path d="M7 21.9l-4-4 4-4"/><path d="M21 11.8v2a4 4 0 0 1-4 4H4.2"/></svg></button>
                                <input type="range" class="slider anim-slider" min="${anim.T.min}" max="${anim.T.max}" value="${anim.T.current}" step="${(anim.T.max - anim.T.min) / 1000}">
                                <span class="slider-value anim-val">${anim.T.current.toFixed(2)}</span>
                            </section>
            
                            <div class="v-mode-content hidden">
                                <label class="legend-checkbox p-2 font-bold">
                                    <input type="checkbox" data-mode="v" class="mode-enable-toggle h-4 w-4" ${anim.modes.v ? 'checked' : ''}> Enable V-Mode (Geometry)
                                </label>
                                <fieldset class="anim-tray-fieldset">
                                    <legend>Animation Control</legend>
                                    <div class="grid grid-cols-2 gap-2">
                                        <input type="number" value="${anim.T.min}" data-range="min" class="compact-input anim-controller-range">
                                        <input type="number" value="${anim.T.max}" data-range="max" class="compact-input anim-controller-range">
                                        <input type="number" value="${anim.speed}" step="0.01" data-range="speed" class="compact-input anim-controller-speed">
                                        <select class="compact-select anim-easing-select">${easingOptions}</select>
            
                                        ${Object.keys(anim.targetVars || {}).map(v => `
                                        <div class="col-span-2">
                                            <label class="legend-checkbox">
                                                <input type="checkbox" data-var="${v}" class="var-toggle h-3 w-3" ${anim.targetVars[v] ? 'checked' : ''}>
                                                Override ${v.toUpperCase()}
                                            </label>
                                            <div class="grid grid-cols-2 gap-2 mt-1">
                                                <input type="number" value="${anim.varRanges[v].min}" placeholder="Min" data-var="${v}" data-range="min" class="compact-input anim-var-range">
                                                <input type="number" value="${anim.varRanges[v].max}" placeholder="Max" data-var="${v}" data-range="max" class="compact-input anim-var-range">
                                            </div>
                                        </div>
                                        `).join('')}
                                        </div>
                                </fieldset>
                            </div>
            
                            <div class="p-mode-content hidden">
                                <label class="legend-checkbox p-2 font-bold">
                                    <input type="checkbox" data-mode="p" class="mode-enable-toggle h-4 w-4" ${anim.modes.p ? 'checked' : ''}> Enable P-Mode (Transforms)
                                </label>
                                <div class="space-y-2 p-1">
                                    <div>
                                        <label class="p-mode-row-label">Position Offset (X,Y,Z)</label>
                                        <div class="grid grid-cols-3 gap-2"><input type="text" class="compact-input" data-type="pos" data-axis="x" value="${anim.pos.x}"><input type="text" class="compact-input" data-type="pos" data-axis="y" value="${anim.pos.y}"><input type="text" class="compact-input" data-type="pos" data-axis="z" value="${anim.pos.z}"></div>
                                    </div>
                                    <div>
                                        <label class="p-mode-row-label">Rotation Offset (deg)</label>
                                        <div class="grid grid-cols-3 gap-2"><input type="text" class="compact-input" data-type="rot" data-axis="x" value="${anim.rot.x}"><input type="text" class="compact-input" data-type="rot" data-axis="y" value="${anim.rot.y}"><input type="text" class="compact-input" data-type="rot" data-axis="z" value="${anim.rot.z}"></div>
                                    </div>
                                    <div>
                                        <label class="p-mode-row-label">Scale (X,Y,Z)</label>
                                        <div class="grid grid-cols-3 gap-2"><input type="text" class="compact-input" data-type="scale" data-axis="x" value="${anim.scale.x}"><input type="text" class="compact-input" data-type="scale" data-axis="y" value="${anim.scale.y}"><input type="text" class="compact-input" data-type="scale" data-axis="z" value="${anim.scale.z}"></div>
                                    </div>
                                </div>
                            </div>
            
                            <div class="physics-mode-content hidden">
                                <label class="legend-checkbox p-2 font-bold">
                                    <input type="checkbox" data-mode="physics" class="mode-enable-toggle h-4 w-4" ${anim.modes.physics ? 'checked' : ''}> Enable Physics
                                </label>
                                <div class="space-y-1">
                                    <fieldset class="anim-tray-fieldset">
                                        <legend>Properties</legend>
                                        <div class="grid grid-cols-2 gap-2">
                                            <input type="number" step="0.1" class="compact-input" placeholder="Mass" data-prop="mass" value="${anim.path.physics.mass}">
                                            <input type="number" step="0.1" class="compact-input" placeholder="Gravity" data-prop="gravity" value="${anim.path.physics.gravity}">
                                            <input type="text" class="compact-input col-span-2" placeholder="Thrust (Expression)" data-prop="thrust" value="${anim.path.physics.thrust}">
                                            <input type="number" step="0.01" class="compact-input col-span-2" placeholder="Drag Coeff." data-prop="drag" value="${anim.path.physics.drag}">
                                            <label class="legend-checkbox mt-1 col-span-2"><input type="checkbox" class="path-auto-rotate h-4 w-4" ${anim.path.autoRotate ? 'checked' : ''}>Auto-Rotate</label>
                                        </div>
                                    </fieldset>
                                    <fieldset class="anim-tray-fieldset">
                                        <legend>Waypoints</legend>
                                        <div class="waypoints-container"></div>
                                        <button class="btn btn-secondary btn-sm w-full mt-1 text-xs p-1 add-waypoint-btn">Add Waypoint</button>
                                    </fieldset>
                                </div>
                            </div>
                        </div>`;
                    cardsContainer.innerHTML += controllerHTML;
                });
            
                this.setupGlobalAnimationTrayListeners();
            }

            setupGlobalAnimationTrayListeners() {
                this.animationTray.querySelectorAll('.anim-tray-controller').forEach(controller => {
                    const objectId = controller.dataset.objectId;
                    const obj = this.getPlaygroundObject(objectId);
                    if (!obj) return;
                    const anim = obj.animation;

                    const panels = {
                        'v-mode': controller.querySelector('.v-mode-content'),
                        'p-mode': controller.querySelector('.p-mode-content'),
                        'physics-mode': controller.querySelector('.physics-mode-content')
                    };
                    controller.querySelectorAll('input[type="radio"][name^="panel-toggle-"]').forEach(radio => {
                        radio.addEventListener('change', () => {
                            Object.values(panels).forEach(p => p.classList.add('hidden'));
                            if (panels[radio.value]) panels[radio.value].classList.remove('hidden');
                        });
                        if (radio.checked) radio.dispatchEvent(new Event('change'));
                    });

                    controller.querySelectorAll('.mode-enable-toggle').forEach(checkbox => {
                        checkbox.addEventListener('change', (e) => {
                            anim.modes[e.target.dataset.mode] = e.target.checked;
                            this.plotter.updatePathVisualizer(objectId, anim.modes.physics ? anim.path.waypoints : []);
                        });
                    });
            
                    controller.querySelector('.anim-play-pause')?.addEventListener('click', () => this.toggleAnimation(objectId));
                    controller.querySelector('.anim-reset-btn')?.addEventListener('click', () => this.resetAnimationAndInputs(objectId));
                    const loopBtn = controller.querySelector('.anim-loop-toggle');
                    if (loopBtn) {
                        loopBtn.classList.toggle('active', !!anim.loop);
                        loopBtn.addEventListener('click', () => { anim.loop = !anim.loop; loopBtn.classList.toggle('active', anim.loop); });
                    }
                    const slider = controller.querySelector('.anim-slider');
                    if (slider) {
                        slider.addEventListener('input', () => {
                            anim.T.current = parseFloat(slider.value);
                            if (!anim.isPlaying) { this.replotWithAnimationOverrides(obj); this.applyAdvancedTransforms(obj); }
                        });
                    }
                    const debouncedReplot = this.debounce(() => { if (!anim.isPlaying) this.replotWithAnimationOverrides(obj); }, 500);

                    controller.querySelectorAll('.v-mode-content .anim-controller-range, .v-mode-content .anim-controller-speed, .v-mode-content .anim-easing-select, .v-mode-content .var-toggle, .v-mode-content .anim-var-range').forEach(input => {
                       const eventType = (input.type === 'checkbox' || input.tagName === 'SELECT') ? 'change' : 'input';
                       input.addEventListener(eventType, () => {
                           if (input.classList.contains('var-toggle')) {
                                anim.targetVars[input.dataset.var] = input.checked;
                           } else if (input.classList.contains('anim-var-range')) {
                                anim.varRanges[input.dataset.var][input.dataset.range] = parseFloat(input.value);
                           } else {
                               const val = input.tagName === 'SELECT' ? input.value : parseFloat(input.value);
                               if (input.classList.contains('anim-easing-select')) anim.easing = val;
                               else if (input.classList.contains('anim-controller-speed')) anim.speed = val;
                               else anim.T[input.dataset.range] = val;
                           }
                           if (slider) { slider.min = anim.T.min; slider.max = anim.T.max; }
                           debouncedReplot();
                       });
                    });

                    controller.querySelectorAll('.p-mode-content input[type="text"]').forEach(input => {
                       input.addEventListener('input', () => {
                           anim[input.dataset.type][input.dataset.axis] = input.value;
                           if (!anim.isPlaying) this.applyAdvancedTransforms(obj);
                       });
                    });
                    
                    controller.querySelectorAll('.physics-mode-content input, .physics-mode-content .path-auto-rotate').forEach(input => {
                        const event = input.type === 'checkbox' ? 'change' : 'input';
                        input.addEventListener(event, e => {
                            if (e.target.classList.contains('path-auto-rotate')) anim.path.autoRotate = e.target.checked;
                            const prop = e.target.dataset.prop;
                            if(prop) anim.path.physics[prop] = e.target.type === 'number' ? parseFloat(e.target.value) : e.target.value;
                        });
                    });
                    controller.querySelector('.add-waypoint-btn')?.addEventListener('click', () => {
                        anim.path.waypoints.push({x:0, y:0, z:0});
                        this.renderWaypoints(objectId);
                    });
                    this.renderWaypoints(objectId);
                });
            }

            renderWaypoints(objectId) {
                const obj = this.getPlaygroundObject(objectId);
                if (!obj || !obj.animation) return;
                const container = this.animationTray.querySelector(`.anim-tray-controller[data-object-id="${objectId}"] .waypoints-container`);
                if (!container) return;
                
                container.innerHTML = '';
                obj.animation.path.waypoints.forEach((wp, index) => {
                    const item = document.createElement('div');
                    item.className = 'waypoint-item';
                    item.innerHTML = `
                        <input type="number" step="0.1" class="compact-input" data-axis="x" value="${wp.x}">
                        <input type="number" step="0.1" class="compact-input" data-axis="y" value="${wp.y}">
                        <input type="number" step="0.1" class="compact-input" data-axis="z" value="${wp.z}">
                        <button class="icon-btn waypoint-remove-btn hover:bg-red-500/20 hover:text-red-400"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg></button>
                    `;
                    container.appendChild(item);

                    item.querySelectorAll('input').forEach(input => {
                        input.addEventListener('input', (e) => {
                            obj.animation.path.waypoints[index][e.target.dataset.axis] = parseFloat(e.target.value) || 0;
                            this.plotter.updatePathVisualizer(objectId, obj.animation.path.waypoints);
                        });
                    });
                    item.querySelector('.waypoint-remove-btn').addEventListener('click', () => {
                        obj.animation.path.waypoints.splice(index, 1);
                        this.renderWaypoints(objectId);
                        this.plotter.updatePathVisualizer(objectId, obj.animation.path.waypoints);
                    });
                });
                this.plotter.updatePathVisualizer(objectId, obj.animation.activeMode === 'physics' ? obj.animation.path.waypoints : []);
            }

            getDefaultAnimationConfig(type) {
                const base = {
                    isPlaying: false, loop: false, lastPlotTimestamp: 0, direction: 1, name: 'T',
                    modes: { v: true, p: false, physics: false },
                    T: { min: 0, max: 10, current: 0 }, speed: 1.0, easing: 'linear',
                    pos: { x: '0', y: '0', z: '0' },
                    rot: { mode: 'euler', x: '0', y: '0', z: '0', ax: '0', ay: '0', az: '1', angle: 'T*90' },
                    scale: { x: '1', y: '1', z: '1' },
                    visibility: 'true',
                    path: {
                        waypoints: [{x:0, y:0, z:0}, {x:5, y:5, z:5}],
                        autoRotate: true,
                        physics: {
                            mass: 1.0,
                            thrust: '100',
                            gravity: 9.8,
                            drag: 0.1,
                            _velocity: new THREE.Vector3(),
                            _previousPosition: null,
                            _currentWaypoint: 0,
                            _position: new THREE.Vector3(),
                            _quaternion: new THREE.Quaternion()
                        }
                    }
                };
                switch(type) {
                    case 'surface': return {...base, T: { min: -5, max: 5, current: -5 }, targetVars: { x: false, y: false }, varRanges: { x: { min: -5, max: 5 }, y: { min: -5, max: 5 } } };
                    case 'parametric': return {...base, T: { min: 0, max: 6.28, current: 0 }, targetVars: { u: false, v: false }, varRanges: { u: { min: 0, max: 6.28 }, v: { min: 0, max: 6.28 } } };
                    case 'curve': return {...base, T: { min: 0, max: 10, current: 0 }, targetVars: { t: true }, varRanges: { t: { min: 0, max: 10 } } };
                    case 'vector': return {...base, T: { min: -3, max: 3, current: -3 }, targetVars: { x: false, y: false, z: false }, varRanges: { x: { min: -3, max: 3 }, y: { min: -3, max: 3 }, z: { min: -3, max: 3 } } };
                    
                    case 'implicit': return {...base, T: { min: -5, max: 5, current: -5 }, targetVars: { x: false, y: false, z: false }, varRanges: { x: { min: -5, max: 5 }, y: { min: -5, max: 5 }, z: { min: -5, max: 5 } } };
                    default: return null;
                }
            }

            updateAnimationValueDisplays(objectId, clear=false) {
                const obj = this.getPlaygroundObject(objectId);
                if (!obj || !obj.animation) return;
                const controller = this.animationTray.querySelector(`.anim-tray-controller[data-object-id="${objectId}"]`);
                if (!controller) return;

                const slider = controller.querySelector('.anim-slider');
                const valueSpan = controller.querySelector('.anim-val');

                slider.value = obj.animation.T.current;
                valueSpan.textContent = obj.animation.T.current.toFixed(2);

                const percent = ((slider.value - slider.min) / (slider.max - slider.min)) * 100;
                const accent = getComputedStyle(controller).getPropertyValue('--component-accent');
                slider.style.background = `linear-gradient(to right, ${accent} ${percent}%, var(--bg-input) ${percent}%)`;

                controller.querySelectorAll('.p-mode-live-value').forEach(span => {
                    span.textContent = clear ? '' : span.textContent;
                });
            }

            isAnyAnimationPlaying() {
                return this.playgroundObjects.some(obj => obj.animation && obj.animation.isPlaying);
            }

            updateGlobalPlayPauseButton() {
                const isPlaying = this.isAnyAnimationPlaying();
                this.globalPlayIcon.classList.toggle('hidden', isPlaying);
                this.globalPauseIcon.classList.toggle('hidden', !isPlaying);
                this.globalPlayPauseBtn.classList.toggle('btn-primary', isPlaying);
                this.globalPlayPauseBtn.classList.toggle('btn-secondary', !isPlaying);
            }

            toggleAllAnimations() {
                if (this.isAnyAnimationPlaying()) {
                    this.pauseAllAnimations();
                } else {
                    this.playAllAnimations();
                }
            }
            toggleAllOverrides() {
                
                const overrideCheckboxes = this.animationTray.querySelectorAll('.var-toggle:not(:disabled)');
                if (overrideCheckboxes.length === 0) return;
            
                
                
                
                const shouldCheckAll = Array.from(overrideCheckboxes).some(cb => !cb.checked);
            
                overrideCheckboxes.forEach(checkbox => {
                    if (checkbox.checked !== shouldCheckAll) {
                        checkbox.checked = shouldCheckAll;
                        
                        checkbox.dispatchEvent(new Event('change', { bubbles: true }));
                    }
                });
            
                this.showToast(shouldCheckAll ? 'All overrides enabled' : 'All overrides disabled');
            }

            playAllAnimations() {
                this.playgroundObjects.forEach(obj => {
                    if (obj.animation && !obj.animation.isPlaying) {
                        this.startAnimation(obj.id);
                    }
                });
            }

            pauseAllAnimations() {
                this.playgroundObjects.forEach(obj => {
                    if (obj.animation && obj.animation.isPlaying) {
                        this.stopAnimation(obj.id);
                    }
                });
            }

            toggleAnimation(objectId) {
                const obj = this.getPlaygroundObject(objectId);
                if (!obj || !obj.animation) return;
                if (obj.animation.isPlaying) this.stopAnimation(objectId);
                else this.startAnimation(objectId);
            }

            resetAnimation(objectId) {
                const obj = this.getPlaygroundObject(objectId);
                if (!obj || !obj.animation) return;
                this.stopAnimation(objectId);
                obj.animation.T.current = obj.animation.T.min;
                obj.animation.direction = 1;
                
                if (obj.animation.modes.physics) {
                    const phys = obj.animation.path.physics;
                    phys._velocity.set(0, 0, 0);
                    phys._previousPosition = null;
                    phys._currentWaypoint = 0;

                    if (obj.threeMesh && obj.animation.path.waypoints.length > 0) {
                        const start = obj.animation.path.waypoints[0];
                        phys._position.set(start.x, start.y, start.z);
                        phys._quaternion.identity();
                        obj.threeMesh.position.copy(phys._position);
                        obj.threeMesh.quaternion.copy(phys._quaternion);
                    }
                }
            
                this.updateAnimationValueDisplays(objectId);
            }

            runPhysicsStep(obj, deltaTime) {
                const { path, T } = obj.animation;
                const phys = path.physics;
                const { waypoints, autoRotate } = path;
                
                const defaultTransform = { position: phys._position, quaternion: phys._quaternion };

                if (waypoints.length === 0 || phys._currentWaypoint >= waypoints.length || deltaTime <= 0) {
                    this.stopAnimation(obj.id);
                    return defaultTransform;
                }

                const currentPos = phys._position.clone();
                
                if (phys._previousPosition === null) {
                    phys._previousPosition = currentPos.clone().sub(phys._velocity.clone().multiplyScalar(deltaTime));
                }

                const netForce = new THREE.Vector3(0, 0, 0);
                const targetWp = waypoints[phys._currentWaypoint];
                const targetPos = new THREE.Vector3(targetWp.x, targetWp.y, targetWp.z);
                
                let thrustMag = 0;
                const thrustInput = document.querySelector(`.anim-tray-controller[data-object-id="${obj.id}"] input[data-prop="thrust"]`);
                try {
                    const expr = phys.thrust;
                    if (!this.expressionCache[expr]) {
                        this.expressionCache[expr] = math.parse(expr).compile();
                    }
                    thrustMag = this.expressionCache[expr].evaluate({ T: T.current });
                    if(thrustInput) thrustInput.classList.remove('input-error');
                } catch(e) { 
                    if(thrustInput) thrustInput.classList.add('input-error');
                    this.stopAnimation(obj.id);
                    return defaultTransform;
                }
                
                if (currentPos.distanceTo(targetPos) > 0.1) {
                    const thrustForce = new THREE.Vector3().subVectors(targetPos, currentPos).normalize().multiplyScalar(thrustMag);
                    netForce.add(thrustForce);
                }

                const gravityForce = new THREE.Vector3(0, 0, -phys.gravity * phys.mass);
                netForce.add(gravityForce);

                const dragForce = phys._velocity.clone().multiplyScalar(-phys.drag);
                netForce.add(dragForce);
                
                const acceleration = netForce.divideScalar(phys.mass || 1);
                const displacement = currentPos.clone().sub(phys._previousPosition).add(acceleration.multiplyScalar(deltaTime * deltaTime));
                const newPosition = currentPos.clone().add(displacement);
                
                phys._previousPosition.copy(currentPos);
                phys._velocity.copy(displacement).divideScalar(deltaTime);

                if (currentPos.distanceTo(targetPos) < 1.0 && phys._currentWaypoint < waypoints.length - 1) {
                    phys._currentWaypoint++;
                }

                let newQuaternion = phys._quaternion.clone();
                if (autoRotate && phys._velocity.lengthSq() > 0.001) {
                    const up = new THREE.Vector3(0, 0, 1);
                    const lookAtMatrix = new THREE.Matrix4().lookAt(newPosition, newPosition.clone().add(phys._velocity), up);
                    const targetQuaternion = new THREE.Quaternion().setFromRotationMatrix(lookAtMatrix);
                    newQuaternion.slerp(targetQuaternion, 0.1);
                }
                
                phys._position.copy(newPosition);
                phys._quaternion.copy(newQuaternion);
                
                return { position: phys._position, quaternion: phys._quaternion };
            }

            applyAdvancedTransforms(obj, deltaTime = 0.016) {
                if (!obj || !obj.animation || !obj.threeMesh) return;
                const anim = obj.animation;
                const mesh = obj.threeMesh;

                let finalPosition = new THREE.Vector3();
                let finalQuaternion = new THREE.Quaternion();
                let finalScale = new THREE.Vector3(1, 1, 1);

                if (anim.modes.physics) {
                    const physicsResult = this.runPhysicsStep(obj, deltaTime);
                    finalPosition.copy(physicsResult.position);
                    finalQuaternion.copy(physicsResult.quaternion);
                } else {
                    finalPosition.set(0,0,0);
                    finalQuaternion.identity();
                }
                
                if (anim.modes.p) {
                    const scope = { T: anim.T.current, PI: Math.PI, sin: Math.sin, cos: Math.cos, tan: Math.tan, exp: Math.exp, log: Math.log, sqrt: Math.sqrt, abs: Math.abs, sign: Math.sign };
                    
                    const evaluate = (expr, inputElement) => {
                        try {
                            if (!this.expressionCache[expr]) {
                                this.expressionCache[expr] = math.parse(expr).compile();
                            }
                            const result = this.expressionCache[expr].evaluate(scope);
                            if(inputElement) inputElement.classList.remove('input-error');
                            return isFinite(result) ? result : 0;
                        } catch (e) {
                            if(inputElement) inputElement.classList.add('input-error');
                            return 0;
                        }
                    };
                    
                    const controllerSelector = `.anim-tray-controller[data-object-id="${obj.id}"]`;

                    const posX = evaluate(anim.pos.x, document.querySelector(`${controllerSelector} input[data-type="pos"][data-axis="x"]`));
                    const posY = evaluate(anim.pos.y, document.querySelector(`${controllerSelector} input[data-type="pos"][data-axis="y"]`));
                    const posZ = evaluate(anim.pos.z, document.querySelector(`${controllerSelector} input[data-type="pos"][data-axis="z"]`));
                    
                    if (anim.modes.physics) {
                        finalPosition.add(new THREE.Vector3(posX, posY, posZ));
                    } else {
                        finalPosition.set(posX, posY, posZ);
                    }

                    const rotX = evaluate(anim.rot.x, document.querySelector(`${controllerSelector} input[data-type="rot"][data-axis="x"]`));
                    const rotY = evaluate(anim.rot.y, document.querySelector(`${controllerSelector} input[data-type="rot"][data-axis="y"]`));
                    const rotZ = evaluate(anim.rot.z, document.querySelector(`${controllerSelector} input[data-type="rot"][data-axis="z"]`));
                    const pModeEuler = new THREE.Euler(THREE.MathUtils.degToRad(rotX), THREE.MathUtils.degToRad(rotY), THREE.MathUtils.degToRad(rotZ));
                    const pModeQuat = new THREE.Quaternion().setFromEuler(pModeEuler);

                    if (anim.modes.physics) {
                        finalQuaternion.multiply(pModeQuat);
                    } else {
                        finalQuaternion.copy(pModeQuat);
                    }

                    const scaleX = evaluate(anim.scale.x, document.querySelector(`${controllerSelector} input[data-type="scale"][data-axis="x"]`)) || 1;
                    const scaleY = evaluate(anim.scale.y, document.querySelector(`${controllerSelector} input[data-type="scale"][data-axis="y"]`)) || 1;
                    const scaleZ = evaluate(anim.scale.z, document.querySelector(`${controllerSelector} input[data-type="scale"][data-axis="z"]`)) || 1;
                    finalScale.set(scaleX, scaleY, scaleZ);
                }
                
                mesh.position.copy(finalPosition);
                mesh.quaternion.copy(finalQuaternion);
                mesh.scale.copy(finalScale);
            }

            resetAllAnimationsAndInputs() {
                this.playgroundObjects.forEach(obj => {
                    if (obj.animation) {
                        this.resetAnimationAndInputs(obj.id);
                    }
                });
                this.showToast('All animations have been reset.');
            }
            resetAnimationAndInputs(objectId) {
                const obj = this.getPlaygroundObject(objectId);
                if (!obj || !obj.animation) {
                    return;
                }
            
                obj.animation.isPlaying = false;
                
                if (this.globalAnimationFrameId && !this.isAnyAnimationPlaying()) {
                    cancelAnimationFrame(this.globalAnimationFrameId);
                    this.globalAnimationFrameId = null;
                    this.globalLastTimestamp = 0;
                }
                
                const defaultConfig = this.getDefaultAnimationConfig(obj.type);
                
                obj.animation = $.extend(true, {}, defaultConfig, { isPlaying: false });
            
                this.renderGlobalAnimationTray();
                
                this.replotWithAnimationOverrides(obj);
                this.applyAdvancedTransforms(obj);
                
                this.updateGlobalPlayPauseButton();
                this.updateControlledUI(false);
            }

            startAnimation(objectId) {
                const obj = this.getPlaygroundObject(objectId);
                if (!obj || !obj.animation || obj.animation.isPlaying) return;

                if (obj.animation.T.current >= obj.animation.T.max) {
                    this.resetAnimation(objectId);
                }

                if (obj.animation.activeMode === 'physics') {
                    this.resetAnimation(objectId);
                }

                obj.animation.isPlaying = true;
                obj.animation.lastPlotTimestamp = 0;

                const perfPreset = this.animationPerformancePresets[this.currentAnimationPerformance];
                if (obj.config.quality) {
                    obj.originalQuality = obj.config.quality;
                    obj.config.quality = Math.max(20, Math.round(obj.originalQuality * perfPreset.qualityFactor));
                }

                const btn = this.animationTray.querySelector(`.anim-tray-controller[data-object-id="${objectId}"] .anim-play-pause`);
                if(btn) {
                    btn.classList.add('active');
                    btn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="10" y1="15" x2="10" y2="9"></line><line x1="14" y1="15" x2="14" y2="9"></line></svg>`;
                }

                if (!this.globalAnimationFrameId) {
                    this.globalAnimationFrameId = requestAnimationFrame((timestamp) => this.globalAnimationLoop(timestamp));
                }
                this.updateControlledUI(true);
                this.updateGlobalPlayPauseButton();
            }

            stopAnimation(objectId) {
                const obj = this.getPlaygroundObject(objectId);
                if (!obj || !obj.animation || !obj.animation.isPlaying) return;

                obj.animation.isPlaying = false;

                if (obj.originalQuality) {
                    obj.config.quality = obj.originalQuality;
                    delete obj.originalQuality;
                }
                
                this.updateAnimationValueDisplays(objectId, true);
                this.replotWithAnimationOverrides(obj, false);

                const btn = this.animationTray.querySelector(`.anim-tray-controller[data-object-id="${objectId}"] .anim-play-pause`);
                 if(btn) {
                    btn.classList.remove('active');
                    btn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>`;
                }
                this.updateControlledUI(false);
                this.updateGlobalPlayPauseButton();
            }

            stopAllAnimations() { 
                this.playgroundObjects.forEach(obj => { if (obj.animation && obj.animation.isPlaying) this.stopAnimation(obj.id); }); 
                this.updateGlobalPlayPauseButton();
            }

            globalAnimationLoop(now) {
                if (!this.globalLastTimestamp) {
                    this.globalLastTimestamp = now;
                    this.globalAnimationFrameId = requestAnimationFrame((timestamp) => this.globalAnimationLoop(timestamp));
                    return;
                }
                
                const deltaTime = (now - this.globalLastTimestamp) / 1000;
                this.globalLastTimestamp = now;

                if (!this.isAnyAnimationPlaying()) {
                    this.globalAnimationFrameId = null;
                    this.globalLastTimestamp = 0;
                    this.accumulator = 0;
                    this.updateControlledUI(false);
                    this.updateGlobalPlayPauseButton();
                    return;
                }
                
                this.accumulator += Math.min(deltaTime, 0.1);

                while (this.accumulator >= this.FIXED_TIMESTEP) {
                    this.playgroundObjects.forEach(obj => {
                        if (obj.animation && obj.animation.isPlaying) {
                            const anim = obj.animation;
                            anim.T.current += anim.speed * anim.direction * this.FIXED_TIMESTEP;

                            if (anim.T.current >= anim.T.max) {
                                if (anim.loop) anim.T.current = anim.T.min;
                                else {
                                    anim.T.current = anim.T.max;
                                    this.stopAnimation(obj.id);
                                }
                            }
                            if (anim.T.current < anim.T.min) {
                                if (anim.loop) anim.T.current = anim.T.max;
                                else {
                                    anim.T.current = anim.T.min;
                                    this.stopAnimation(obj.id);
                                }
                            }
                            
                            this.updateAnimationValueDisplays(obj.id);
                            
                            if (anim.modes.p || anim.modes.physics) {
                                this.applyAdvancedTransforms(obj, this.FIXED_TIMESTEP);
                            }
                        }
                    });
                    this.accumulator -= this.FIXED_TIMESTEP;
                }

                this.playgroundObjects.forEach(obj => {
                    if (obj.animation && obj.animation.isPlaying && obj.animation.modes.v) {
                        const perfPreset = this.animationPerformancePresets[this.currentAnimationPerformance];
                        if (now - obj.animation.lastPlotTimestamp > perfPreset.throttle) {
                            obj.animation.lastPlotTimestamp = now;
                            this.replotWithAnimationOverrides(obj, true);
                        }
                    }
                });

                this.globalAnimationFrameId = requestAnimationFrame((timestamp) => this.globalAnimationLoop(timestamp));
            }
            updateControlledUI(isAnimating) {
                document.querySelectorAll('.form-input[data-anim-var]').forEach(input => {
                    const varName = input.dataset.animVar;
                    const objectContainer = input.closest('[data-object-id]');
                    if (!objectContainer) return;

                    const objectId = objectContainer.dataset.objectId;
                    const obj = this.getPlaygroundObject(objectId);
                    
                    if (obj && obj.animation && obj.animation.isPlaying && obj.animation.activeMode === 'v-mode' && obj.animation.targetVars[varName]) {
                        input.classList.add('anim-controlled');
                    } else {
                        input.classList.remove('anim-controlled');
                    }
                });
            }

            replotWithAnimationOverrides(obj, isFromAnimation = false) {
                if (!obj || !obj.animation) return;
                const anim = obj.animation;
            
                const T_range = anim.T.max - anim.T.min;
                const T_progress = T_range === 0 ? 1 : (anim.T.current - anim.T.min) / T_range;
            
                const easingFunction = this.Easing[anim.easing] || this.Easing.linear;
                const eased_progress = easingFunction(T_progress);
                
                const animationOptions = {};
                let shouldPlot = false;
            
                for (const varName in anim.targetVars) {
                    if (anim.targetVars[varName]) {
                        shouldPlot = true;
                        const varRange = anim.varRanges[varName];
                        const mappedValue = varRange.min + eased_progress * (varRange.max - varRange.min);
                        animationOptions[`${varName}MaxOverride`] = mappedValue;
                    }
                }
                if (shouldPlot || !isFromAnimation) this.plot(obj.id, animationOptions, isFromAnimation);
            }
            
            getLatestMathExpr(id, baseId) { const field = this.mathFields[baseId + '-' + id]; return this.convertLatexToMathJs(field ? field.latex() : '0'); }

            convertLatexToMathJs(latex) {
                if (!latex) return '';
                let s = latex.replace(/\\cdot/g, '*').replace(/\\left\(/g, '(').replace(/\\right\)/g, ')').replace(//g, 'pi').replace(/\{/g, '(').replace(/\}/g, ')');
                const trigFuncs = 'sin|cos|tan|sec|csc|cot|asin|acos|atan|ln|log';
                s = s.replace(new RegExp(`\\\\(${trigFuncs})`, 'g'), '$1');
                for (let i=0; i<5; i++) {
                    s = s.replace(/e\^(\([^)]+\)|[a-zA-Z0-9\.]+)/g, 'exp($1)');
                    s = s.replace(/\\sqrt\(([^)]+)\)/g, 'sqrt($1)');
                    s = s.replace(/\\frac\(([^)]+)\)\(([^)]+)\)/g, '(($1)/($2))');
                 }
                return s;
            }

            plot(id, animationOptions = {}, isFromAnimation = false, isQueuedPlot = false) {
                const obj = this.getPlaygroundObject(id);
                if (!obj) return;
                
                if (obj.type === 'single-vector') {
                    
                    this.plotter.updateSinglePlot(obj, false);
                    this.applyAdvancedTransforms(obj);
                    return;
                }
            
                if (this.isPlotting.has(id) && isFromAnimation) return;
                if (!isFromAnimation) {
                    const card = document.querySelector(`[data-object-id="${id}"]`);
                    card?.classList.add('is-plotting');
                }
                this.isPlotting.add(id);
            
                const scope = { T: obj.animation ? obj.animation.T.current : 0 };
                let params = { id, mode: obj.type, ...obj.config, ...animationOptions, scope };
            
                
                if (obj.type === 'implicit') {
                    params.slicingEnabled = this.slicingEnabledToggle.checked;
                    params.sliceAxes = Array.from(this.sliceAxisCheckboxes)
                                            .filter(cb => cb.checked)
                                            .map(cb => cb.value);
                    params.slicePositions = {
                        x: parseFloat(this.slicePositionSliders.x.value),
                        y: parseFloat(this.slicePositionSliders.y.value),
                        z: parseFloat(this.slicePositionSliders.z.value)
                    };
                }
                
            
                try {
                    switch(obj.type) {
                        case 'surface': params.equation = this.getLatestMathExpr(id, 'eq'); break;
                        case 'vector': params.fx = this.getLatestMathExpr(id, 'vx'); params.fy = this.getLatestMathExpr(id, 'vy'); params.fz = this.getLatestMathExpr(id, 'vz'); break;
                        case 'parametric': params.xExpr = this.getLatestMathExpr(id, 'px'); params.yExpr = this.getLatestMathExpr(id, 'py'); params.zExpr = this.getLatestMathExpr(id, 'pz'); break;
                        case 'curve': params.xExpr = this.getLatestMathExpr(id, 'cx'); params.yExpr = this.getLatestMathExpr(id, 'cy'); params.zExpr = this.getLatestMathExpr(id, 'cz'); break;
                        case 'implicit': params.equation = this.getLatestMathExpr(id, 'imp'); break;
                    }
                } catch(e) { this.isPlotting.delete(id); this.showError(e.message, id); this.hideLoading(); return; }
            
                this.worker.postMessage(params);
                if (!isFromAnimation) this.debouncedAutoSave();
            }
            updateCoords(text) {
                // Add a check to make sure this.plotter is initialized
                if (this.plotter) {
                    const displayText = text ? text : 'Hover for coordinates...';
                    this.plotter.updateHUDText(displayText);
                }
            }

            showLoading() { this.loadingOverlay.classList.remove('hidden'); setTimeout(() => this.loadingOverlay.style.opacity = '1', 10); this.hideError(); }
            hideLoading() { if (this.isPlotting.size > 0) return; this.loadingOverlay.style.opacity = '0'; setTimeout(() => this.loadingOverlay.classList.add('hidden'), 300); }
            showError(message = "Please check your input.", id) { const errorEl = document.getElementById(`error-${id}`); if (errorEl) { errorEl.textContent = message; errorEl.classList.remove('hidden'); } if (this.isPlotting.size === 0) this.hideLoading(); }
            hideError(id) { if (id) { const errorEl = document.getElementById(`error-${id}`); if (errorEl) errorEl.classList.add('hidden'); } else { document.querySelectorAll('.error-badge').forEach(el => el.classList.add('hidden')); } }
            showToast(message) { this.toastEl.textContent = message; this.toastEl.classList.add('show'); setTimeout(() => { this.toastEl.classList.remove('show'); }, 3000); }

            copyToClipboard(text, message) {
                const textArea = document.createElement('textarea');
                textArea.value = text;
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    this.showToast(message);
                } catch (err) {
                    this.showToast('Failed to copy!');
                }
                document.body.removeChild(textArea);
            }

            syncUItoState() {
                this.playgroundObjects.forEach(obj => {
                    const container = document.querySelector(`[data-object-id="${obj.id}"]`);
                    if (!container) return;
                    container.querySelectorAll('input[data-config], select[data-config]').forEach(el => {
                        const key = el.dataset.config;
                        if (key && obj.config.hasOwnProperty(key)) {
                            const value = el.type === 'checkbox' ? el.checked : (el.type === 'color' ? el.value : (el.type === 'number' || el.type === 'range' ? parseFloat(el.value) : el.value));
                            obj.config[key] = value;
                        }
                    });
                    if (obj.type === 'single-vector') return;
                    try {
                        switch(obj.type) {
                            case 'surface': obj.config.equation = this.mathFields[`eq-${obj.id}`]?.latex(); break;
                            case 'parametric': obj.config.xExpr = this.mathFields[`px-${obj.id}`]?.latex(); obj.config.yExpr = this.mathFields[`py-${obj.id}`]?.latex(); obj.config.zExpr = this.mathFields[`pz-${obj.id}`]?.latex(); break;
                            case 'curve': obj.config.xExpr = this.mathFields[`cx-${obj.id}`]?.latex(); obj.config.yExpr = this.mathFields[`cy-${obj.id}`]?.latex(); obj.config.zExpr = this.mathFields[`cz-${obj.id}`]?.latex(); break;
                            case 'vector': obj.config.fx = this.mathFields[`vx-${obj.id}`]?.latex(); obj.config.fy = this.mathFields[`vy-${obj.id}`]?.latex(); obj.config.fz = this.mathFields[`vz-${obj.id}`]?.latex(); break;
                            case 'implicit': obj.config.equation = this.mathFields[`imp-${obj.id}`]?.latex(); break;
                        }
                    } catch(e) { this.showToast("Could not sync MathField state"); }
                });
            }

            collectSettings() {
                const statesToSave = JSON.parse(JSON.stringify(this.modeStates));
                statesToSave[this.currentMode] = this.playgroundObjects;

                for (const mode in statesToSave) {
                    statesToSave[mode].forEach(obj => {
                        delete obj.lastData;
                        delete obj.threeMesh;
                        if (obj.animation) {
                             delete obj.animation.lastPlotTimestamp;
                             delete obj.animation.isPlaying;
                             delete obj.animation.direction;
                        }
                    });
                }
                const settings = {
                    version: 'threejs-3.0-path-animation',
                    mode: this.currentMode,
                    focusedObjectId: this.focusedObjectId,
                    modeStates: statesToSave,
                    animationPerformance: this.currentAnimationPerformance
                };
                return settings;
            }
            shareState() {
                try {
                    const settings = this.collectSettings();
                    const jsonString = JSON.stringify(settings);
                    const compressed = pako.deflate(jsonString, { to: 'string' });
                    const encoded = btoa(compressed);
                    const url = `${window.location.origin}${window.location.pathname}?s=${encodeURIComponent(encoded)}`;
                    this.copyToClipboard(url, 'Sharable link copied to clipboard!');
                } catch (e) { this.showToast('Error creating share link.'); }
            }

            saveSettings() {
                try {
                    const settings = this.collectSettings();
                    const jsonString = JSON.stringify(settings, null, 2);
                    const blob = new Blob([jsonString], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'plotter-pro-settings.json';
                    a.click();
                    URL.revokeObjectURL(url);
                    this.showToast('Settings saved!');
                } catch(e) { this.showToast('Error saving settings.'); }
            }

            exportSTL() {
                const exporter = new THREE.STLExporter();
                let objectToExport = null;
                let objectName = 'plot';

                if (this.currentMode === 'playground') {
                    if (!this.focusedObjectId) {
                        this.showToast('Please focus an object to export.');
                        return;
                    }
                    const obj = this.getPlaygroundObject(this.focusedObjectId);
                    if (obj && obj.threeMesh) {
                        objectToExport = obj.threeMesh;
                        objectName = obj.name;
                    }
                } else {
                    const obj = this.playgroundObjects[0];
                    if (obj && obj.threeMesh) {
                        objectToExport = obj.threeMesh;
                        objectName = obj.name;
                    }
                }

                if (!objectToExport) {
                    this.showToast('No valid object selected for export.');
                    return;
                }

                try {
                    const stlString = exporter.parse(objectToExport);
                    const blob = new Blob([stlString], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${objectName.replace(/ /g, '_')}.stl`;
                    a.click();
                    URL.revokeObjectURL(url);
                    this.showToast('STL file exported!');
                } catch (e) {
                    this.showToast('Error exporting STL file.');
                }
            }

            exportGLTF() {
                const exporter = new THREE.GLTFExporter();
                let objectToExport = null;
                let objectName = 'plot';

                if (this.currentMode === 'playground') {
                    if (!this.focusedObjectId) { this.showToast('Please focus an object to export.'); return; }
                    const obj = this.getPlaygroundObject(this.focusedObjectId);
                    if (obj && obj.threeMesh) { objectToExport = obj.threeMesh; objectName = obj.name; }
                } else {
                    const obj = this.playgroundObjects[0];
                    if (obj && obj.threeMesh) { objectToExport = obj.threeMesh; objectName = obj.name; }
                }

                if (!objectToExport) { this.showToast('No valid object selected for export.'); return; }

                exporter.parse(objectToExport, (gltf) => {
                    const output = JSON.stringify(gltf, null, 2);
                    const blob = new Blob([output], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${objectName.replace(/ /g, '_')}.gltf`;
                    a.click();
                    URL.revokeObjectURL(url);
                    this.showToast('GLTF file exported!');
                }, (error) => {
                    this.showToast('Error exporting GLTF file.');
                });
            }

            loadStateFromURL() {
                const urlParams = new URLSearchParams(window.location.search);
                const stateParam = urlParams.get('s');
                if (stateParam) {
                    try {
                        const decoded = atob(decodeURIComponent(stateParam));
                        const decompressed = pako.inflate(decoded, { to: 'string' });
                        const settings = JSON.parse(decompressed);
                        this.applySettings(settings);
                        return true;
                    } catch (e) { this.showToast('Error loading shared link.'); return false; }
                }
                return false;
            }

            loadSettings(event) {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const settings = JSON.parse(e.target.result);
                        this.applySettings(settings);
                        this.showToast('Settings loaded!');
                    } catch (err) { this.showToast('Error: Invalid settings file.'); }
                };
                reader.readAsText(file);
                event.target.value = '';
            }

            applySettings(settings) {
                this.stopAllAnimations();
                if (settings.animationPerformance && this.animationPerformancePresets[settings.animationPerformance]) {
                    this.currentAnimationPerformance = settings.animationPerformance;
                }
                this.modeStates = settings.modeStates || { playground: [], surface: [], parametric: [], curve: [], vector: [] };
                 for (const mode in this.modeStates) {
                    this.modeStates[mode].forEach(obj => {
                        const defaultConfig = this.getDefaultConfig(obj.type);
                        if (obj.config) {
                            obj.config = { ...defaultConfig, ...obj.config };
                        } else {
                            obj.config = defaultConfig;
                        }
            
                        const baseAnimState = this.getDefaultAnimationConfig(obj.type);
                        if (baseAnimState) {
                             if (obj.animation) {
                                obj.animation = $.extend(true, {}, baseAnimState, obj.animation);
                             } else {
                                obj.animation = baseAnimState;
                             }
                        }
                    });
                }
                this.focusedObjectId = settings.focusedObjectId || null;
                this.switchMode(settings.mode || 'playground', true);
            }

            initializeCalculator() {
                this.calculatorPopup = document.getElementById('calculator-popup');
                this.calculatorKeypad = document.getElementById('calculator-keypad');
                this.calculatorCloseBtn = document.getElementById('calculator-close-btn');
                this.calculatorDoneBtn = document.getElementById('calculator-done-btn');
                this.calculatorDragHandle = document.getElementById('calculator-drag-handle');
                this.activeCalculatorFieldId = null;

                const MQ = MathQuill.getInterface(2);
                const calculatorDisplayMQ = document.getElementById('calculator-display-mq');
                this.calculatorMathField = MQ.MathField(calculatorDisplayMQ, {
                    spaceBehavesLikeTab: true,
                    handlers: {
                        edit: () => {
                            if (this.activeCalculatorFieldId && this.mathFields[this.activeCalculatorFieldId]) {
                                const sourceField = this.mathFields[this.activeCalculatorFieldId];
                                sourceField.latex(this.calculatorMathField.latex());
                            }
                        }
                    }
                });

                const keys = [
                    { t: 'sin', v: '\\sin', c: 'fn-key' }, { t: 'cos', v: '\\cos', c: 'fn-key' }, { t: 'tan', v: '\\tan', c: 'fn-key' }, { t: '', v: '\\pi' }, { t: 'e', v: 'e' },
                    { t: '(', v: '(' }, { t: ')', v: ')' }, { t: '', v: '\\sqrt', c: 'fn-key' }, { t: 'x', v: '^2' }, { t: 'x', v: '^' },
                    { t: '7', v: '7' }, { t: '8', v: '8' }, { t: '9', v: '9' }, { t: '', v: '/', c: 'op-key' }, { t: '', v: 'Backspace', c: 'op-key' },
                    { t: '4', v: '4' }, { t: '5', v: '5' }, { t: '6', v: '6' }, { t: '', v: '\\cdot', c: 'op-key' }, { t: 'T', v: 'T' },
                    { t: '1', v: '1' }, { t: '2', v: '2' }, { t: '3', v: '3' }, { t: '', v: '-', c: 'op-key' }, { t: 'u', v: 'u' },
                    { t: '0', v: '0' }, { t: '.', v: '.' }, { t: 'x', v: 'x' }, { t: '+', v: '+', c: 'op-key' }, { t: 'v', v: 'v' }
                ];

                this.calculatorKeypad.innerHTML = keys.map(k => `<button class="${k.c || ''}" data-value="${k.v}">${k.t}</button>`).join('');

                this.calculatorKeypad.addEventListener('click', e => {
                    if (e.target.tagName === 'BUTTON') {
                        const value = e.target.dataset.value;
                        if (value === 'Backspace') {
                            this.calculatorMathField.keystroke('Backspace');
                        } else if (['\\sin', '\\cos', '\\tan', '\\sqrt', '\\cdot', '/', '^'].includes(value)) {
                            this.calculatorMathField.cmd(value);
                        } else {
                            this.calculatorMathField.write(value);
                        }
                        this.calculatorMathField.focus();
                    }
                });

                this.calculatorCloseBtn.addEventListener('click', () => this.closeCalculator());
                this.calculatorDoneBtn.addEventListener('click', () => this.closeCalculator());

                let isDragging = false, offsetX, offsetY;
                this.calculatorDragHandle.addEventListener('mousedown', e => {
                    isDragging = true;
                    offsetX = e.clientX - this.calculatorPopup.offsetLeft;
                    offsetY = e.clientY - this.calculatorPopup.offsetTop;
                    this.calculatorPopup.style.transition = 'none';
                });
                document.addEventListener('mousemove', e => {
                    if (isDragging) {
                        this.calculatorPopup.style.left = `${e.clientX - offsetX}px`;
                        this.calculatorPopup.style.top = `${e.clientY - offsetY}px`;
                    }
                });
                document.addEventListener('mouseup', () => {
                    isDragging = false;
                    this.calculatorPopup.style.transition = '';
                });
            }

            openCalculator(fieldId, triggerBtn) {
                this.activeCalculatorFieldId = fieldId;
                const sourceField = this.mathFields[fieldId];
                if (!sourceField) return;

                this.calculatorMathField.latex(sourceField.latex());

                this.calculatorPopup.classList.remove('hidden');

                const rect = triggerBtn.getBoundingClientRect();
                this.calculatorPopup.style.top = `${rect.bottom + 10}px`;
                this.calculatorPopup.style.left = `${rect.left - this.calculatorPopup.offsetWidth / 2 + rect.width / 2}px`;
                
                setTimeout(() => this.calculatorMathField.focus(), 0);
            }

            closeCalculator() {
                this.calculatorPopup.classList.add('hidden');
                if (this.activeCalculatorFieldId && this.mathFields[this.activeCalculatorFieldId]) {
                    this.mathFields[this.activeCalculatorFieldId].focus();
                }
                this.activeCalculatorFieldId = null;
            }

            destroyMathFields(container) {      
                container.querySelectorAll('.mq-initialized').forEach(span => {
                    const id = span.id;
                    if (this.mathFields && this.mathFields[id]) {
                        this.mathFields[id].revert();
                        delete this.mathFields[id];
                        if (this.mathFieldHistory) delete this.mathFieldHistory[id];
                        if (this.mathFieldHistoryPointer) delete this.mathFieldHistoryPointer[id];
                    }
                });
            }
        }

        document.addEventListener('DOMContentLoaded', () => { window.app = new AppController(); });
    </script>
    <div id="calculator-popup" class="hidden fixed z-50 bg-gray-800 border-2 border-blue-500/50 rounded-lg shadow-2xl p-3" style="width:290px;">
        <div id="calculator-drag-handle" class="flex justify-between items-center pb-2 mb-2 border-b border-gray-700 cursor-move">
            <span class="text-sm font-bold text-blue-400">Math Assistant</span>
            <button id="calculator-close-btn" class="text-gray-400 hover:text-white text-2xl leading-none">&times;</button>
        </div>
        <div class="w-full bg-gray-900 border border-gray-700 rounded-md p-1 mb-3">
            <span id="calculator-display-mq"></span>
        </div>
        <div id="calculator-keypad" class="grid grid-cols-5 gap-2">
            </div>
        <div class="mt-3">
            <button id="calculator-done-btn" class="w-full btn btn-primary">Done</button>
        </div>
    </div>


    <div id="info-modal-overlay" class="fixed inset-0 bg-black/60 backdrop-blur-sm z-[1000] flex items-center justify-center p-4 hidden">
        <div id="info-modal-panel" class="bg-bg-sidebar border border-border-color rounded-lg shadow-2xl p-6 w-full max-w-2xl text-text-light flex flex-col" style="min-height: 500px;">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold">Welcome to 6AxisAnimation!</h2>
                <button id="info-modal-close-btn" class="tool-button !w-9 !h-9">&times;</button>
            </div>
    
            <div class="flex-grow relative">
                
                <div class="info-slide absolute inset-0 space-y-3">
                    <h3 class="font-bold text-lg text-text-light">1. The Playground</h3>
                    <p>This is your 3D canvas. Start by clicking the <code class="bg-bg-input px-2 py-1 rounded-md font-mono text-xs text-color-primary">+ Add Object</code> button in the **left panel** to choose a plot type. You can add multiple objects to create complex scenes.</p>
                    <img src="https://i.imgur.com/8Q5kG5L.png" alt="Playground UI Highlight" class="rounded-lg border border-border-color">
                </div>
    
                <div class="info-slide absolute inset-0 space-y-3">
                    <h3 class="font-bold text-lg text-text-light">2. Configuration Panel</h3>
                    <p>Each object you create appears as a card in the left panel. Click on a card's header to expand its settings. Here you can change its **mathematical formula, color, quality**, and more.</p>
                    <img src="https://i.imgur.com/uR2iL1u.png" alt="Configuration Panel Highlight" class="rounded-lg border border-border-color">
                </div>
    
                <div class="info-slide absolute inset-0 space-y-3">
                    <h3 class="font-bold text-lg text-text-light">3. The Animation Panel</h3>
                    <p>When an object can be animated, its controller appears in the **right panel**. Here, you can bring your plots to life using three powerful modes. In any mode, the variable `T` in your formulas corresponds to the main slider's value.</p>
                    <img src="https://i.imgur.com/k28b1xT.png" alt="Animation Panel UI" class="rounded-lg border border-border-color">
                </div>
    
                <div class="info-slide absolute inset-0 space-y-3">
                    <h3 class="font-bold text-lg" style="color: var(--color-primary);">V-Mode (Variable Mode)</h3>
                    <p class="font-semibold">Use this mode to animate an object's **shape and internal geometry**.</p>
                    <div class="text-sm space-y-3 p-3 bg-bg-input rounded-md border border-border-subtle">
                        <p><b>How it works:</b> V-Mode lets the main `T` slider take control of a plot's core variables (like `x`, `u`, or `t`).</p>
                        <ol class="list-decimal list-inside ml-2">
                            <li><b>Enable V-Mode</b> by ticking its checkbox.</li>
                            <li><b>Select a Variable</b> by ticking an "OVERRIDE" box (e.g., for `X`).</li>
                            <li><b>Set the Range</b> for the override.</li>
                            <li>As you move the `T` slider, the object's geometry will be re-plotted in real-time, with the `X` value changing according to `T`'s position in your new range.</li>
                        </ol>
                    </div>
                </div>
    
                <div class="info-slide absolute inset-0 space-y-3">
                    <h3 class="font-bold text-lg" style="color: var(--color-secondary);">P-Mode (Transform Mode)</h3>
                    <p class="font-semibold">Use this mode to animate an object's **Position, Rotation, and Scale**.</p>
                     <div class="text-sm space-y-3 p-3 bg-bg-input rounded-md border border-border-subtle">
                        <p><b>How it works:</b> P-Mode applies transforms *after* the object is plotted, moving it as a whole without changing its shape.</p>
                        <ol class="list-decimal list-inside ml-2">
                           <li><b>Enable P-Mode</b> by ticking its checkbox.</li>
                           <li>Enter mathematical formulas using `T` into any of the transform fields.</li>
                        </ol>
                        <p class="font-semibold mt-2">Example: Move an object from (5, 2, 0) to (-8, 0, 10)</p>
                        <ul class="list-disc list-inside ml-2">
                            <li>Set the main T-slider range from **Min: 0** to **Max: 1**.</li>
                            <li>In the Position fields, enter these linear interpolation formulas:
                                <div class="grid grid-cols-3 gap-2 my-1">
                                    <code class="bg-bg-input-focus p-2 rounded font-mono text-xs text-center">X: 5 - 13*T</code>
                                    <code class="bg-bg-input-focus p-2 rounded font-mono text-xs text-center">Y: 2 - 2*T</code>
                                    <code class="bg-bg-input-focus p-2 rounded font-mono text-xs text-center">Z: 10*T</code>
                                </div>
                            </li>
                        </ul>
                    </div>
                </div>
    
                <div class="info-slide absolute inset-0 space-y-3">
                    <h3 class="font-bold text-lg" style="color: var(--color-accent);">Physics Mode</h3>
                    <p class="font-semibold">Use this mode for simple, physics-based path animation.</p>
                     <div class="text-sm space-y-3 p-3 bg-bg-input rounded-md border border-border-subtle">
                        <p><b>How it works:</b> The object attempts to fly between waypoints using forces. The `T` slider represents time elapsed.</p>
                        <ol class="list-decimal list-inside ml-2">
                            <li><b>Enable Physics</b> by ticking its checkbox.</li>
                            <li><b>Add Waypoints</b> to create a path for the object to target.</li>
                            <li><b>Set Properties</b> like Mass, Gravity, and Thrust.</li>
                        </ol>
                        <p class="font-semibold mt-2">Example: A 5-second rocket launch</p>
                        <ul class="list-disc list-inside ml-2">
                            <li>Add a waypoint high above the origin (e.g., at 0, 0, 50).</li>
                            <li>Set the `Thrust` property to an expression that turns off after 5 seconds: <br><code class="bg-bg-input-focus p-2 rounded font-mono text-xs">if(T < 5, 2000, 0)</code></li>
                        </ul>
                    </div>
                </div>
    
                <div class="info-slide absolute inset-0 space-y-3 flex flex-col items-center justify-center text-center">
                    <h3 class="font-bold text-lg text-text-light">You're All Set!</h3>
                    <p>You can re-watch this guide anytime by clicking the <br> <code class="bg-bg-input p-1 rounded font-mono text-xs">( i )</code> button in the top-right toolbar.</p>
                    <p class="mt-4">Happy plotting!</p>
                </div>
            </div>
    
            <div class="flex justify-between items-center mt-auto pt-4 border-t border-border-color">
                <button id="info-modal-prev" class="btn btn-secondary">Previous</button>
                <div id="info-modal-counter" class="text-sm font-mono"></div>
                <button id="info-modal-next" class="btn btn-primary">Next</button>
            </div>
        </div>
    </div>

    <div id="tutorial-highlighter"></div>
    <div id="tutorial-modal-overlay" class="fixed inset-0 bg-black/70 z-[2000] flex items-center justify-center p-4 hidden">
        <div id="tutorial-modal-panel" class="bg-bg-sidebar border border-border-color rounded-lg shadow-2xl p-6 w-full max-w-sm text-text-light flex flex-col">
            <h2 id="tutorial-title" class="text-xl font-bold mb-3"></h2>
            <p id="tutorial-text" class="text-text-label text-sm mb-4 flex-grow"></p>
            <div class="flex justify-between items-center mt-auto pt-4 border-t border-border-color">
                <button id="tutorial-prev-btn" class="btn btn-secondary">Previous</button>
                <div id="tutorial-counter" class="text-sm font-mono"></div>
                <button id="tutorial-next-btn" class="btn btn-primary">Next</button>
            </div>
        </div>
    </div>

    <div id="rotate-prompt" class="hidden fixed inset-0 bg-bg-main-start z-[9999] flex-col items-center justify-center text-center p-4">
        <div class="phone-container mb-6">
            <svg xmlns="http://www.w3.org/2000/svg" width="80" height="80" viewBox="0 0 24 24" class="mb-2">
                <g class="animating-phone">
                    <rect x="7" y="3" width="10" height="18" rx="2" stroke="var(--color-primary)" stroke-width="1.5" fill="none"/>
                    <circle cx="12" cy="6" r="0.5" fill="var(--color-primary)"/>
                    <rect x="10" y="18" width="4" height="1" rx="0.5" fill="var(--color-primary)"/>
                </g>
            </svg>
            <div class="w-12 h-1 bg-gradient-to-r from-transparent via-blue-500 to-transparent rounded-full opacity-50"></div>
        </div>
        <h2 class="text-3xl font-bold text-text-light mb-3 tracking-tight">Rotate Your Device</h2>
        <p class="text-text-muted text-sm leading-relaxed max-w-sm">Turn your device to landscape mode or use desktop for the best experience</p>
        <div class="mt-4 flex space-x-1">
            <div class="w-2 h-2 bg-blue-500 rounded-full animate-pulse"></div>
            <div class="w-2 h-2 bg-blue-500 rounded-full animate-pulse" style="animation-delay: 0.2s;"></div>
            <div class="w-2 h-2 bg-blue-500 rounded-full animate-pulse" style="animation-delay: 0.4s;"></div>
        </div>
    </div>

</body>
</html>